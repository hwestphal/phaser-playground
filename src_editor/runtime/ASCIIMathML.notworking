var deadCounter = 1000
// function nodeAppendChild(node, value) {
//     console.log('%cAppendChild', 'background-color:yellow;', node, value)
//     node.appendChild(value)
// }

/*
ASCIIMathML.js
==============
modified by Tom Berend - 
only a TS function that accepts AsciiMath and returns MathML.  
Don't touch my document, I'll do that.  
and don't worry about IE.



================================
Version 2.2 Mar 3, 2014.
Latest version at https://github.com/mathjax/asciimathml
If you use it on a webpage, please send the URL to jipsen@chapman.edu

Copyright (c) 2014 Peter Jipsen and other ASCIIMathML.js contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/


export function testAsciiMath() {
    let a = asciiMath('sum_(i=1)^n i^3=((n(n+1))/2)^2')
    console.log('completed')
    console.log(a)
}
export function asciiMath(str: string): Node {
    return new AsciiMath().parseMath(str)
}




let mathcolor = "blue"        // change it to "" (to inherit) or another color
let mathfontsize = "1em"      // change to e.g. 1.2em for larger math
let mathfontfamily = "serif"  // change to "" to inherit (works in IE)
// or another family (e.g. "arial")
let automathrecognize = false // writing "amath" on page makes this true
let checkForMathML = true     // check if browser can display MathML
let notifyIfnoMathMl = true   // display note at top if no MathML capability
let alertIfnoMathMl = false   // show alert box if no MathML capability
let translateOnLoad = true    // set to false to do call translators from js
let displaystyle = true      // puts limits above and below large operators
let showasciiformulaonhover = true // helps students learn ASCIIMath
let decimalsign = "."        // if "," then when writing lists or matrices put
//a space after the "," like `(1, 2)` not `(1,2)`
let AMdelimiter1 = "`", AMescape1 = "\\\\`" // can use other characters
let AMdocumentId = "wikitext" // PmWiki element containing math (default=body)
let fixphi = true  		//false to return to legacy phi/varphi mapping


// character lists for Mozilla/Netscape fonts
let AMcal = ["\uD835\uDC9C", "\u212C", "\uD835\uDC9E", "\uD835\uDC9F", "\u2130", "\u2131", "\uD835\uDCA2", "\u210B", "\u2110", "\uD835\uDCA5", "\uD835\uDCA6", "\u2112", "\u2133", "\uD835\uDCA9", "\uD835\uDCAA", "\uD835\uDCAB", "\uD835\uDCAC", "\u211B", "\uD835\uDCAE", "\uD835\uDCAF", "\uD835\uDCB0", "\uD835\uDCB1", "\uD835\uDCB2", "\uD835\uDCB3", "\uD835\uDCB4", "\uD835\uDCB5", "\uD835\uDCB6", "\uD835\uDCB7", "\uD835\uDCB8", "\uD835\uDCB9", "\u212F", "\uD835\uDCBB", "\u210A", "\uD835\uDCBD", "\uD835\uDCBE", "\uD835\uDCBF", "\uD835\uDCC0", "\uD835\uDCC1", "\uD835\uDCC2", "\uD835\uDCC3", "\u2134", "\uD835\uDCC5", "\uD835\uDCC6", "\uD835\uDCC7", "\uD835\uDCC8", "\uD835\uDCC9", "\uD835\uDCCA", "\uD835\uDCCB", "\uD835\uDCCC", "\uD835\uDCCD", "\uD835\uDCCE", "\uD835\uDCCF"]

let AMfrk = ["\uD835\uDD04", "\uD835\uDD05", "\u212D", "\uD835\uDD07", "\uD835\uDD08", "\uD835\uDD09", "\uD835\uDD0A", "\u210C", "\u2111", "\uD835\uDD0D", "\uD835\uDD0E", "\uD835\uDD0F", "\uD835\uDD10", "\uD835\uDD11", "\uD835\uDD12", "\uD835\uDD13", "\uD835\uDD14", "\u211C", "\uD835\uDD16", "\uD835\uDD17", "\uD835\uDD18", "\uD835\uDD19", "\uD835\uDD1A", "\uD835\uDD1B", "\uD835\uDD1C", "\u2128", "\uD835\uDD1E", "\uD835\uDD1F", "\uD835\uDD20", "\uD835\uDD21", "\uD835\uDD22", "\uD835\uDD23", "\uD835\uDD24", "\uD835\uDD25", "\uD835\uDD26", "\uD835\uDD27", "\uD835\uDD28", "\uD835\uDD29", "\uD835\uDD2A", "\uD835\uDD2B", "\uD835\uDD2C", "\uD835\uDD2D", "\uD835\uDD2E", "\uD835\uDD2F", "\uD835\uDD30", "\uD835\uDD31", "\uD835\uDD32", "\uD835\uDD33", "\uD835\uDD34", "\uD835\uDD35", "\uD835\uDD36", "\uD835\uDD37"]

let AMbbb = ["\uD835\uDD38", "\uD835\uDD39", "\u2102", "\uD835\uDD3B", "\uD835\uDD3C", "\uD835\uDD3D", "\uD835\uDD3E", "\u210D", "\uD835\uDD40", "\uD835\uDD41", "\uD835\uDD42", "\uD835\uDD43", "\uD835\uDD44", "\u2115", "\uD835\uDD46", "\u2119", "\u211A", "\u211D", "\uD835\uDD4A", "\uD835\uDD4B", "\uD835\uDD4C", "\uD835\uDD4D", "\uD835\uDD4E", "\uD835\uDD4F", "\uD835\uDD50", "\u2124", "\uD835\uDD52", "\uD835\uDD53", "\uD835\uDD54", "\uD835\uDD55", "\uD835\uDD56", "\uD835\uDD57", "\uD835\uDD58", "\uD835\uDD59", "\uD835\uDD5A", "\uD835\uDD5B", "\uD835\uDD5C", "\uD835\uDD5D", "\uD835\uDD5E", "\uD835\uDD5F", "\uD835\uDD60", "\uD835\uDD61", "\uD835\uDD62", "\uD835\uDD63", "\uD835\uDD64", "\uD835\uDD65", "\uD835\uDD66", "\uD835\uDD67", "\uD835\uDD68", "\uD835\uDD69", "\uD835\uDD6A", "\uD835\uDD6B"]
/*var AMcal = [0xEF35,0x212C,0xEF36,0xEF37,0x2130,0x2131,0xEF38,0x210B,0x2110,0xEF39,0xEF3A,0x2112,0x2133,0xEF3B,0xEF3C,0xEF3D,0xEF3E,0x211B,0xEF3F,0xEF40,0xEF41,0xEF42,0xEF43,0xEF44,0xEF45,0xEF46]
let AMfrk = [0xEF5D,0xEF5E,0x212D,0xEF5F,0xEF60,0xEF61,0xEF62,0x210C,0x2111,0xEF63,0xEF64,0xEF65,0xEF66,0xEF67,0xEF68,0xEF69,0xEF6A,0x211C,0xEF6B,0xEF6C,0xEF6D,0xEF6E,0xEF6F,0xEF70,0xEF71,0x2128]
let AMbbb = [0xEF8C,0xEF8D,0x2102,0xEF8E,0xEF8F,0xEF90,0xEF91,0x210D,0xEF92,0xEF93,0xEF94,0xEF95,0xEF96,0x2115,0xEF97,0x2119,0x211A,0x211D,0xEF98,0xEF99,0xEF9A,0xEF9B,0xEF9C,0xEF9D,0xEF9E,0x2124]*/


type Tag = 'div' | 'p' | 'span' | 'body' | 'a'

const COMMENT_NODE = 8          // DOM:  Node.nodeType.COMMENT_NODE
const nameSpaceURI = "http://www.w3.org/1999/xhtml"
const AMmathmlURI = "http://www.w3.org/1998/Math/MathML"

enum tokenType {
    CONST = 0, UNARY = 1, BINARY = 2, INFIX = 3, LEFTBRACKET = 4,
    RIGHTBRACKET = 5, SPACE = 6, UNDEROVER = 7, DEFINITION = 8,
    LEFTRIGHT = 9, TEXT = 10, BIG = 11, LONG = 12, STRETCHY = 13,
    MATRIX = 14, UNARYUNDEROVER = 15 // token types
}


type AMSymbol = {
    input: string
    tag: 'mi' | 'mo' | 'mroot' | 'mfrac' | 'msup' | 'msub' | 'mover' | 'mtext' | 'msqrt' | 'munder' | 'mstyle' | 'menclose' | 'mrow'
    output: string
    tex: string | null
    ttype: tokenType

    invisible?: boolean         // all these other unreliable elements ?!?!
    func?: boolean
    acc?: boolean
    rewriteleftright?: string[]  // always two 
    notexcopy?: boolean

    atname?: "mathvariant",
    atval?: "bold" | "sans-serif" | "double-struck" | "script" | "fraktur" | "monospace"
    codes?: string[]   // AMcal | AMfrk | AMbbb | 
}

let AMquote: AMSymbol = { input: "\"", tag: "mtext", output: "mbox", tex: null, ttype: tokenType.TEXT }


let AMsymbols: AMSymbol[] = [
    //some greek symbols
    { input: "alpha", tag: "mi", output: "\u03B1", tex: null, ttype: tokenType.CONST },
    { input: "beta", tag: "mi", output: "\u03B2", tex: null, ttype: tokenType.CONST },
    { input: "chi", tag: "mi", output: "\u03C7", tex: null, ttype: tokenType.CONST },
    { input: "delta", tag: "mi", output: "\u03B4", tex: null, ttype: tokenType.CONST },
    { input: "Delta", tag: "mo", output: "\u0394", tex: null, ttype: tokenType.CONST },
    { input: "epsi", tag: "mi", output: "\u03B5", tex: "epsilon", ttype: tokenType.CONST },
    { input: "varepsilon", tag: "mi", output: "\u025B", tex: null, ttype: tokenType.CONST },
    { input: "eta", tag: "mi", output: "\u03B7", tex: null, ttype: tokenType.CONST },
    { input: "gamma", tag: "mi", output: "\u03B3", tex: null, ttype: tokenType.CONST },
    { input: "Gamma", tag: "mo", output: "\u0393", tex: null, ttype: tokenType.CONST },
    { input: "iota", tag: "mi", output: "\u03B9", tex: null, ttype: tokenType.CONST },
    { input: "kappa", tag: "mi", output: "\u03BA", tex: null, ttype: tokenType.CONST },
    { input: "lambda", tag: "mi", output: "\u03BB", tex: null, ttype: tokenType.CONST },
    { input: "Lambda", tag: "mo", output: "\u039B", tex: null, ttype: tokenType.CONST },
    { input: "lamda", tag: "mi", output: "\u03BB", tex: null, ttype: tokenType.CONST },
    { input: "Lamda", tag: "mo", output: "\u039B", tex: null, ttype: tokenType.CONST },
    { input: "mu", tag: "mi", output: "\u03BC", tex: null, ttype: tokenType.CONST },
    { input: "nu", tag: "mi", output: "\u03BD", tex: null, ttype: tokenType.CONST },
    { input: "omega", tag: "mi", output: "\u03C9", tex: null, ttype: tokenType.CONST },
    { input: "Omega", tag: "mo", output: "\u03A9", tex: null, ttype: tokenType.CONST },
    { input: "phi", tag: "mi", output: fixphi ? "\u03D5" : "\u03C6", tex: null, ttype: tokenType.CONST },
    { input: "varphi", tag: "mi", output: fixphi ? "\u03C6" : "\u03D5", tex: null, ttype: tokenType.CONST },
    { input: "Phi", tag: "mo", output: "\u03A6", tex: null, ttype: tokenType.CONST },
    { input: "pi", tag: "mi", output: "\u03C0", tex: null, ttype: tokenType.CONST },
    { input: "Pi", tag: "mo", output: "\u03A0", tex: null, ttype: tokenType.CONST },
    { input: "psi", tag: "mi", output: "\u03C8", tex: null, ttype: tokenType.CONST },
    { input: "Psi", tag: "mi", output: "\u03A8", tex: null, ttype: tokenType.CONST },
    { input: "rho", tag: "mi", output: "\u03C1", tex: null, ttype: tokenType.CONST },
    { input: "sigma", tag: "mi", output: "\u03C3", tex: null, ttype: tokenType.CONST },
    { input: "Sigma", tag: "mo", output: "\u03A3", tex: null, ttype: tokenType.CONST },
    { input: "tau", tag: "mi", output: "\u03C4", tex: null, ttype: tokenType.CONST },
    { input: "theta", tag: "mi", output: "\u03B8", tex: null, ttype: tokenType.CONST },
    { input: "vartheta", tag: "mi", output: "\u03D1", tex: null, ttype: tokenType.CONST },
    { input: "Theta", tag: "mo", output: "\u0398", tex: null, ttype: tokenType.CONST },
    { input: "upsilon", tag: "mi", output: "\u03C5", tex: null, ttype: tokenType.CONST },
    { input: "xi", tag: "mi", output: "\u03BE", tex: null, ttype: tokenType.CONST },
    { input: "Xi", tag: "mo", output: "\u039E", tex: null, ttype: tokenType.CONST },
    { input: "zeta", tag: "mi", output: "\u03B6", tex: null, ttype: tokenType.CONST },

    //binary operation symbols
    //{input:"-",  tag:"mo", output:"\u0096", tex:null, ttype:tokenType.CONST},
    { input: "*", tag: "mo", output: "\u22C5", tex: "cdot", ttype: tokenType.CONST },
    { input: "**", tag: "mo", output: "\u2217", tex: "ast", ttype: tokenType.CONST },
    { input: "***", tag: "mo", output: "\u22C6", tex: "star", ttype: tokenType.CONST },
    { input: "//", tag: "mo", output: "/", tex: null, ttype: tokenType.CONST },
    { input: "\\\\", tag: "mo", output: "\\", tex: "backslash", ttype: tokenType.CONST },
    { input: "setminus", tag: "mo", output: "\\", tex: null, ttype: tokenType.CONST },
    { input: "xx", tag: "mo", output: "\u00D7", tex: "times", ttype: tokenType.CONST },
    { input: "|><", tag: "mo", output: "\u22C9", tex: "ltimes", ttype: tokenType.CONST },
    { input: "><|", tag: "mo", output: "\u22CA", tex: "rtimes", ttype: tokenType.CONST },
    { input: "|><|", tag: "mo", output: "\u22C8", tex: "bowtie", ttype: tokenType.CONST },
    { input: "-:", tag: "mo", output: "\u00F7", tex: "div", ttype: tokenType.CONST },
    { input: "divide", tag: "mo", output: "-:", tex: null, ttype: tokenType.DEFINITION },
    { input: "@", tag: "mo", output: "\u2218", tex: "circ", ttype: tokenType.CONST },
    { input: "o+", tag: "mo", output: "\u2295", tex: "oplus", ttype: tokenType.CONST },
    { input: "ox", tag: "mo", output: "\u2297", tex: "otimes", ttype: tokenType.CONST },
    { input: "o.", tag: "mo", output: "\u2299", tex: "odot", ttype: tokenType.CONST },
    { input: "sum", tag: "mo", output: "\u2211", tex: null, ttype: tokenType.UNDEROVER },
    { input: "prod", tag: "mo", output: "\u220F", tex: null, ttype: tokenType.UNDEROVER },
    { input: "^^", tag: "mo", output: "\u2227", tex: "wedge", ttype: tokenType.CONST },
    { input: "^^^", tag: "mo", output: "\u22C0", tex: "bigwedge", ttype: tokenType.UNDEROVER },
    { input: "vv", tag: "mo", output: "\u2228", tex: "vee", ttype: tokenType.CONST },
    { input: "vvv", tag: "mo", output: "\u22C1", tex: "bigvee", ttype: tokenType.UNDEROVER },
    { input: "nn", tag: "mo", output: "\u2229", tex: "cap", ttype: tokenType.CONST },
    { input: "nnn", tag: "mo", output: "\u22C2", tex: "bigcap", ttype: tokenType.UNDEROVER },
    { input: "uu", tag: "mo", output: "\u222A", tex: "cup", ttype: tokenType.CONST },
    { input: "uuu", tag: "mo", output: "\u22C3", tex: "bigcup", ttype: tokenType.UNDEROVER },

    //binary relation symbols
    { input: "!=", tag: "mo", output: "\u2260", tex: "ne", ttype: tokenType.CONST },
    { input: ":=", tag: "mo", output: ":=", tex: null, ttype: tokenType.CONST },
    { input: "lt", tag: "mo", output: "<", tex: null, ttype: tokenType.CONST },
    { input: "<=", tag: "mo", output: "\u2264", tex: "le", ttype: tokenType.CONST },
    { input: "lt=", tag: "mo", output: "\u2264", tex: "leq", ttype: tokenType.CONST },
    { input: "gt", tag: "mo", output: ">", tex: null, ttype: tokenType.CONST },
    { input: "mlt", tag: "mo", output: "\u226A", tex: "ll", ttype: tokenType.CONST },
    { input: ">=", tag: "mo", output: "\u2265", tex: "ge", ttype: tokenType.CONST },
    { input: "gt=", tag: "mo", output: "\u2265", tex: "geq", ttype: tokenType.CONST },
    { input: "mgt", tag: "mo", output: "\u226B", tex: "gg", ttype: tokenType.CONST },
    { input: "-<", tag: "mo", output: "\u227A", tex: "prec", ttype: tokenType.CONST },
    { input: "-lt", tag: "mo", output: "\u227A", tex: null, ttype: tokenType.CONST },
    { input: ">-", tag: "mo", output: "\u227B", tex: "succ", ttype: tokenType.CONST },
    { input: "-<=", tag: "mo", output: "\u2AAF", tex: "preceq", ttype: tokenType.CONST },
    { input: ">-=", tag: "mo", output: "\u2AB0", tex: "succeq", ttype: tokenType.CONST },
    { input: "in", tag: "mo", output: "\u2208", tex: null, ttype: tokenType.CONST },
    { input: "!in", tag: "mo", output: "\u2209", tex: "notin", ttype: tokenType.CONST },
    { input: "sub", tag: "mo", output: "\u2282", tex: "subset", ttype: tokenType.CONST },
    { input: "sup", tag: "mo", output: "\u2283", tex: "supset", ttype: tokenType.CONST },
    { input: "sube", tag: "mo", output: "\u2286", tex: "subseteq", ttype: tokenType.CONST },
    { input: "supe", tag: "mo", output: "\u2287", tex: "supseteq", ttype: tokenType.CONST },
    { input: "-=", tag: "mo", output: "\u2261", tex: "equiv", ttype: tokenType.CONST },
    { input: "~=", tag: "mo", output: "\u2245", tex: "cong", ttype: tokenType.CONST },
    { input: "~~", tag: "mo", output: "\u2248", tex: "approx", ttype: tokenType.CONST },
    { input: "~", tag: "mo", output: "\u223C", tex: "sim", ttype: tokenType.CONST },
    { input: "prop", tag: "mo", output: "\u221D", tex: "propto", ttype: tokenType.CONST },

    //logical symbols
    { input: "and", tag: "mtext", output: "and", tex: null, ttype: tokenType.SPACE },
    { input: "or", tag: "mtext", output: "or", tex: null, ttype: tokenType.SPACE },
    { input: "not", tag: "mo", output: "\u00AC", tex: "neg", ttype: tokenType.CONST },
    { input: "=>", tag: "mo", output: "\u21D2", tex: "implies", ttype: tokenType.CONST },
    { input: "if", tag: "mo", output: "if", tex: null, ttype: tokenType.SPACE },
    { input: "<=>", tag: "mo", output: "\u21D4", tex: "iff", ttype: tokenType.CONST },
    { input: "AA", tag: "mo", output: "\u2200", tex: "forall", ttype: tokenType.CONST },
    { input: "EE", tag: "mo", output: "\u2203", tex: "exists", ttype: tokenType.CONST },
    { input: "_|_", tag: "mo", output: "\u22A5", tex: "bot", ttype: tokenType.CONST },
    { input: "TT", tag: "mo", output: "\u22A4", tex: "top", ttype: tokenType.CONST },
    { input: "|--", tag: "mo", output: "\u22A2", tex: "vdash", ttype: tokenType.CONST },
    { input: "|==", tag: "mo", output: "\u22A8", tex: "models", ttype: tokenType.CONST },

    //grouping brackets
    { input: "(", tag: "mo", output: "(", tex: "left(", ttype: tokenType.LEFTBRACKET },
    { input: ")", tag: "mo", output: ")", tex: "right)", ttype: tokenType.RIGHTBRACKET },
    { input: "[", tag: "mo", output: "[", tex: "left[", ttype: tokenType.LEFTBRACKET },
    { input: "]", tag: "mo", output: "]", tex: "right]", ttype: tokenType.RIGHTBRACKET },
    { input: "{", tag: "mo", output: "{", tex: null, ttype: tokenType.LEFTBRACKET },
    { input: "}", tag: "mo", output: "}", tex: null, ttype: tokenType.RIGHTBRACKET },
    { input: "|", tag: "mo", output: "|", tex: null, ttype: tokenType.LEFTRIGHT },
    { input: ":|:", tag: "mo", output: "|", tex: null, ttype: tokenType.CONST },
    { input: "|:", tag: "mo", output: "|", tex: null, ttype: tokenType.LEFTBRACKET },
    { input: ":|", tag: "mo", output: "|", tex: null, ttype: tokenType.RIGHTBRACKET },
    //{input:"||", tag:"mo", output:"||", tex:null, ttype:LEFTRIGHT},
    { input: "(:", tag: "mo", output: "\u2329", tex: "langle", ttype: tokenType.LEFTBRACKET },
    { input: ":)", tag: "mo", output: "\u232A", tex: "rangle", ttype: tokenType.RIGHTBRACKET },
    { input: "<<", tag: "mo", output: "\u2329", tex: null, ttype: tokenType.LEFTBRACKET },
    { input: ">>", tag: "mo", output: "\u232A", tex: null, ttype: tokenType.RIGHTBRACKET },
    { input: "{:", tag: "mo", output: "{:", tex: null, ttype: tokenType.LEFTBRACKET, invisible: true },
    { input: ":}", tag: "mo", output: ":}", tex: null, ttype: tokenType.RIGHTBRACKET, invisible: true },

    //miscellaneous symbols
    { input: "int", tag: "mo", output: "\u222B", tex: null, ttype: tokenType.CONST },
    { input: "dx", tag: "mi", output: "{:d x:}", tex: null, ttype: tokenType.DEFINITION },
    { input: "dy", tag: "mi", output: "{:d y:}", tex: null, ttype: tokenType.DEFINITION },
    { input: "dz", tag: "mi", output: "{:d z:}", tex: null, ttype: tokenType.DEFINITION },
    { input: "dt", tag: "mi", output: "{:d t:}", tex: null, ttype: tokenType.DEFINITION },
    { input: "oint", tag: "mo", output: "\u222E", tex: null, ttype: tokenType.CONST },
    { input: "del", tag: "mo", output: "\u2202", tex: "partial", ttype: tokenType.CONST },
    { input: "grad", tag: "mo", output: "\u2207", tex: "nabla", ttype: tokenType.CONST },
    { input: "+-", tag: "mo", output: "\u00B1", tex: "pm", ttype: tokenType.CONST },
    { input: "-+", tag: "mo", output: "\u2213", tex: "mp", ttype: tokenType.CONST },
    { input: "O/", tag: "mo", output: "\u2205", tex: "emptyset", ttype: tokenType.CONST },
    { input: "oo", tag: "mo", output: "\u221E", tex: "infty", ttype: tokenType.CONST },
    { input: "aleph", tag: "mo", output: "\u2135", tex: null, ttype: tokenType.CONST },
    { input: "...", tag: "mo", output: "...", tex: "ldots", ttype: tokenType.CONST },
    { input: ":.", tag: "mo", output: "\u2234", tex: "therefore", ttype: tokenType.CONST },
    { input: ":'", tag: "mo", output: "\u2235", tex: "because", ttype: tokenType.CONST },
    { input: "/_", tag: "mo", output: "\u2220", tex: "angle", ttype: tokenType.CONST },
    { input: "/_\\", tag: "mo", output: "\u25B3", tex: "triangle", ttype: tokenType.CONST },
    { input: "'", tag: "mo", output: "\u2032", tex: "prime", ttype: tokenType.CONST },
    { input: "tilde", tag: "mover", output: "~", tex: null, ttype: tokenType.UNARY, acc: true },
    { input: "\\ ", tag: "mo", output: "\u00A0", tex: null, ttype: tokenType.CONST },
    { input: "frown", tag: "mo", output: "\u2322", tex: null, ttype: tokenType.CONST },
    { input: "quad", tag: "mo", output: "\u00A0\u00A0", tex: null, ttype: tokenType.CONST },
    { input: "qquad", tag: "mo", output: "\u00A0\u00A0\u00A0\u00A0", tex: null, ttype: tokenType.CONST },
    { input: "cdots", tag: "mo", output: "\u22EF", tex: null, ttype: tokenType.CONST },
    { input: "vdots", tag: "mo", output: "\u22EE", tex: null, ttype: tokenType.CONST },
    { input: "ddots", tag: "mo", output: "\u22F1", tex: null, ttype: tokenType.CONST },
    { input: "diamond", tag: "mo", output: "\u22C4", tex: null, ttype: tokenType.CONST },
    { input: "square", tag: "mo", output: "\u25A1", tex: null, ttype: tokenType.CONST },
    { input: "|__", tag: "mo", output: "\u230A", tex: "lfloor", ttype: tokenType.CONST },
    { input: "__|", tag: "mo", output: "\u230B", tex: "rfloor", ttype: tokenType.CONST },
    { input: "|~", tag: "mo", output: "\u2308", tex: "lceiling", ttype: tokenType.CONST },
    { input: "~|", tag: "mo", output: "\u2309", tex: "rceiling", ttype: tokenType.CONST },
    { input: "CC", tag: "mo", output: "\u2102", tex: null, ttype: tokenType.CONST },
    { input: "NN", tag: "mo", output: "\u2115", tex: null, ttype: tokenType.CONST },
    { input: "QQ", tag: "mo", output: "\u211A", tex: null, ttype: tokenType.CONST },
    { input: "RR", tag: "mo", output: "\u211D", tex: null, ttype: tokenType.CONST },
    { input: "ZZ", tag: "mo", output: "\u2124", tex: null, ttype: tokenType.CONST },
    { input: "f", tag: "mi", output: "f", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "g", tag: "mi", output: "g", tex: null, ttype: tokenType.UNARY, func: true },

    //standard functions
    { input: "lim", tag: "mo", output: "lim", tex: null, ttype: tokenType.UNDEROVER },
    { input: "Lim", tag: "mo", output: "Lim", tex: null, ttype: tokenType.UNDEROVER },
    { input: "sin", tag: "mo", output: "sin", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "cos", tag: "mo", output: "cos", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "tan", tag: "mo", output: "tan", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "sinh", tag: "mo", output: "sinh", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "cosh", tag: "mo", output: "cosh", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "tanh", tag: "mo", output: "tanh", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "cot", tag: "mo", output: "cot", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "sec", tag: "mo", output: "sec", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "csc", tag: "mo", output: "csc", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "arcsin", tag: "mo", output: "arcsin", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "arccos", tag: "mo", output: "arccos", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "arctan", tag: "mo", output: "arctan", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "coth", tag: "mo", output: "coth", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "sech", tag: "mo", output: "sech", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "csch", tag: "mo", output: "csch", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "exp", tag: "mo", output: "exp", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "abs", tag: "mo", output: "abs", tex: null, ttype: tokenType.UNARY, rewriteleftright: ["|", "|"] },
    { input: "norm", tag: "mo", output: "norm", tex: null, ttype: tokenType.UNARY, rewriteleftright: ["\u2225", "\u2225"] },
    { input: "floor", tag: "mo", output: "floor", tex: null, ttype: tokenType.UNARY, rewriteleftright: ["\u230A", "\u230B"] },
    { input: "ceil", tag: "mo", output: "ceil", tex: null, ttype: tokenType.UNARY, rewriteleftright: ["\u2308", "\u2309"] },
    { input: "log", tag: "mo", output: "log", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "ln", tag: "mo", output: "ln", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "det", tag: "mo", output: "det", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "dim", tag: "mo", output: "dim", tex: null, ttype: tokenType.CONST },
    { input: "mod", tag: "mo", output: "mod", tex: null, ttype: tokenType.CONST },
    { input: "gcd", tag: "mo", output: "gcd", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "lcm", tag: "mo", output: "lcm", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "lub", tag: "mo", output: "lub", tex: null, ttype: tokenType.CONST },
    { input: "glb", tag: "mo", output: "glb", tex: null, ttype: tokenType.CONST },
    { input: "min", tag: "mo", output: "min", tex: null, ttype: tokenType.UNDEROVER },
    { input: "max", tag: "mo", output: "max", tex: null, ttype: tokenType.UNDEROVER },
    { input: "Sin", tag: "mo", output: "Sin", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "Cos", tag: "mo", output: "Cos", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "Tan", tag: "mo", output: "Tan", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "Arcsin", tag: "mo", output: "Arcsin", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "Arccos", tag: "mo", output: "Arccos", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "Arctan", tag: "mo", output: "Arctan", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "Sinh", tag: "mo", output: "Sinh", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "Cosh", tag: "mo", output: "Cosh", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "Tanh", tag: "mo", output: "Tanh", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "Cot", tag: "mo", output: "Cot", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "Sec", tag: "mo", output: "Sec", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "Csc", tag: "mo", output: "Csc", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "Log", tag: "mo", output: "Log", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "Ln", tag: "mo", output: "Ln", tex: null, ttype: tokenType.UNARY, func: true },
    { input: "Abs", tag: "mo", output: "abs", tex: null, ttype: tokenType.UNARY, notexcopy: true, rewriteleftright: ["|", "|"] },

    //arrows
    { input: "uarr", tag: "mo", output: "\u2191", tex: "uparrow", ttype: tokenType.CONST },
    { input: "darr", tag: "mo", output: "\u2193", tex: "downarrow", ttype: tokenType.CONST },
    { input: "rarr", tag: "mo", output: "\u2192", tex: "rightarrow", ttype: tokenType.CONST },
    { input: "->", tag: "mo", output: "\u2192", tex: "to", ttype: tokenType.CONST },
    { input: ">->", tag: "mo", output: "\u21A3", tex: "rightarrowtail", ttype: tokenType.CONST },
    { input: "->>", tag: "mo", output: "\u21A0", tex: "twoheadrightarrow", ttype: tokenType.CONST },
    { input: ">->>", tag: "mo", output: "\u2916", tex: "twoheadrightarrowtail", ttype: tokenType.CONST },
    { input: "|->", tag: "mo", output: "\u21A6", tex: "mapsto", ttype: tokenType.CONST },
    { input: "larr", tag: "mo", output: "\u2190", tex: "leftarrow", ttype: tokenType.CONST },
    { input: "harr", tag: "mo", output: "\u2194", tex: "leftrightarrow", ttype: tokenType.CONST },
    { input: "rArr", tag: "mo", output: "\u21D2", tex: "Rightarrow", ttype: tokenType.CONST },
    { input: "lArr", tag: "mo", output: "\u21D0", tex: "Leftarrow", ttype: tokenType.CONST },
    { input: "hArr", tag: "mo", output: "\u21D4", tex: "Leftrightarrow", ttype: tokenType.CONST },
    //commands with argument
    { input: "sqrt", tag: "msqrt", output: "sqrt", tex: null, ttype: tokenType.UNARY },
    { input: "root", tag: "mroot", output: "root", tex: null, ttype: tokenType.BINARY },
    { input: "frac", tag: "mfrac", output: "/", tex: null, ttype: tokenType.BINARY },
    { input: "/", tag: "mfrac", output: "/", tex: null, ttype: tokenType.INFIX },
    { input: "stackrel", tag: "mover", output: "stackrel", tex: null, ttype: tokenType.BINARY },
    { input: "overset", tag: "mover", output: "stackrel", tex: null, ttype: tokenType.BINARY },
    { input: "underset", tag: "munder", output: "stackrel", tex: null, ttype: tokenType.BINARY },
    { input: "_", tag: "msub", output: "_", tex: null, ttype: tokenType.INFIX },
    { input: "^", tag: "msup", output: "^", tex: null, ttype: tokenType.INFIX },
    { input: "hat", tag: "mover", output: "\u005E", tex: null, ttype: tokenType.UNARY, acc: true },
    { input: "bar", tag: "mover", output: "\u00AF", tex: "overline", ttype: tokenType.UNARY, acc: true },
    { input: "vec", tag: "mover", output: "\u2192", tex: null, ttype: tokenType.UNARY, acc: true },
    { input: "dot", tag: "mover", output: ".", tex: null, ttype: tokenType.UNARY, acc: true },
    { input: "ddot", tag: "mover", output: "..", tex: null, ttype: tokenType.UNARY, acc: true },
    { input: "overarc", tag: "mover", output: "\u23DC", tex: "overparen", ttype: tokenType.UNARY, acc: true },
    { input: "ul", tag: "munder", output: "\u0332", tex: "underline", ttype: tokenType.UNARY, acc: true },
    { input: "ubrace", tag: "munder", output: "\u23DF", tex: "underbrace", ttype: tokenType.UNARYUNDEROVER, acc: true },
    { input: "obrace", tag: "mover", output: "\u23DE", tex: "overbrace", ttype: tokenType.UNARYUNDEROVER, acc: true },
    { input: "text", tag: "mtext", output: "text", tex: null, ttype: tokenType.TEXT },
    { input: "mbox", tag: "mtext", output: "mbox", tex: null, ttype: tokenType.TEXT },
    { input: "color", tag: "mstyle", output: "", tex: null, ttype: tokenType.BINARY },
    { input: "id", tag: "mrow", output: "", tex: null, ttype: tokenType.BINARY },
    { input: "class", tag: "mrow", output: "", tex: null, ttype: tokenType.BINARY },
    { input: "cancel", tag: "menclose", output: "cancel", tex: null, ttype: tokenType.UNARY },
    AMquote,
    { input: "bb", tag: "mstyle", atname: "mathvariant", atval: "bold", output: "bb", tex: null, ttype: tokenType.UNARY },
    { input: "mathbf", tag: "mstyle", atname: "mathvariant", atval: "bold", output: "mathbf", tex: null, ttype: tokenType.UNARY },
    { input: "sf", tag: "mstyle", atname: "mathvariant", atval: "sans-serif", output: "sf", tex: null, ttype: tokenType.UNARY },
    { input: "mathsf", tag: "mstyle", atname: "mathvariant", atval: "sans-serif", output: "mathsf", tex: null, ttype: tokenType.UNARY },
    { input: "bbb", tag: "mstyle", atname: "mathvariant", atval: "double-struck", output: "bbb", tex: null, ttype: tokenType.UNARY, codes: AMbbb },
    { input: "mathbb", tag: "mstyle", atname: "mathvariant", atval: "double-struck", output: "mathbb", tex: null, ttype: tokenType.UNARY, codes: AMbbb },
    { input: "cc", tag: "mstyle", atname: "mathvariant", atval: "script", output: "cc", tex: null, ttype: tokenType.UNARY, codes: AMcal },
    { input: "mathcal", tag: "mstyle", atname: "mathvariant", atval: "script", output: "mathcal", tex: null, ttype: tokenType.UNARY, codes: AMcal },
    { input: "tt", tag: "mstyle", atname: "mathvariant", atval: "monospace", output: "tt", tex: null, ttype: tokenType.UNARY },
    { input: "mathtt", tag: "mstyle", atname: "mathvariant", atval: "monospace", output: "mathtt", tex: null, ttype: tokenType.UNARY },
    { input: "fr", tag: "mstyle", atname: "mathvariant", atval: "fraktur", output: "fr", tex: null, ttype: tokenType.UNARY, codes: AMfrk },
    { input: "mathfrak", tag: "mstyle", atname: "mathvariant", atval: "fraktur", output: "mathfrak", tex: null, ttype: tokenType.UNARY, codes: AMfrk }
]



let AMnames = [] //list of input symbols
let AMnestingDepth: number
let AMpreviousSymbol: tokenType
let AMcurrentSymbol: tokenType



/** convert an AsciiMath statement to MathML */
class AsciiMath {

    noMathMl = false
    translated = false

    constructor() {
        console.log(`constructor()`)
        if (deadCounter-- < 0) throw ('stop')

        this.setStylesheet("#AMMLcloseDiv \{font-size:0.8em padding-top:1em color:#014\}\n#AMMLwarningBox \{position:absolute width:100% top:0 left:0 z-index:200 text-align:center font-size:1em font-weight:bold padding:0.5em 0 0.5em 0 color:#ffc background:#c30\}")

        this.initSymbols()
    }


    // Add a stylesheet, replacing any previous custom stylesheet (adapted from TW)
    setStylesheet(s: string) {
        let id = "AMMLcustomStyleSheet"
        let n = document.getElementById(id) as HTMLStyleElement
        if (n) {
            n.replaceChild(document.createTextNode(s), n.firstChild)
        } else {
            n = document.createElement("style")
            // n.type = "text/css"   // deprecated
            n.id = id
            n.appendChild(document.createTextNode(s))

            document.getElementsByTagName("head")[0].appendChild(n)
        }

    }

    hideWarning() {
        let body = document.getElementsByTagName("body")[0]
        body.removeChild(document.getElementById('AMMLwarningBox'))
        body.onclick = null
    }

    displayWarnings(warnings: string[]) {
        let nd = this.createElementXHTML("div")
        nd.id = 'AMMLwarningBox'

        warnings.forEach(warn => {
            let frag = this.createElementXHTML("div")
            frag.appendChild(document.createTextNode(warn))
            frag.style.paddingBottom = "1.0em"
            nd.appendChild(frag)

        })
        nd.appendChild(this.createElementXHTML("p"))
        nd.appendChild(document.createTextNode("For instructions see the "))
        let an = this.createElementXHTML("a")
        an.appendChild(document.createTextNode("ASCIIMathML"))
        an.setAttribute("href", "http://asciimath.org")
        nd.appendChild(an)
        nd.appendChild(document.createTextNode(" homepage"))
        an = this.createElementXHTML("div")
        an.id = 'AMMLcloseDiv'
        an.appendChild(document.createTextNode('(click anywhere to close this warning)'))
        nd.appendChild(an)

        let body = document.getElementsByTagName("body")[0]
        body.onclick = this.hideWarning
        body.insertBefore(nd, body.childNodes[0])
    }

    createElementXHTML(t: Tag) {
        return document.createElementNS(nameSpaceURI, t)
    }


    createMmlNode(qualifiedName: string, frag?: any): Element {
        let node = document.createElementNS(AMmathmlURI, qualifiedName)
        if (frag)
            node.appendChild(frag)
        console.log(`createMmlNode(${qualifiedName})`)
        return node
    }

    newcommand(oldstr: string, newstr: string) {
        AMsymbols.push({ input: oldstr, tag: "mo", output: newstr, tex: null, ttype: tokenType.DEFINITION })
        this.refreshSymbols()
    }

    newsymbol(symbolobj) {
        AMsymbols.push(symbolobj)
        this.refreshSymbols()
    }

    compareNames(s1: AMSymbol, s2: AMSymbol): number {
        if (s1.input > s2.input) return 1
        else return -1
    }


    initSymbols() {
        let i
        let symlen = AMsymbols.length
        for (i = 0; i < symlen; i++) {
            if (AMsymbols[i].tex) {
                AMsymbols.push({
                    input: AMsymbols[i].tex,
                    tag: AMsymbols[i].tag,
                    output: AMsymbols[i].output,
                    tex: null,
                    ttype: AMsymbols[i].ttype,
                    invisible: (AMsymbols[i].acc || false)
                })
            }
        }
        this.refreshSymbols()
    }

    refreshSymbols() {
        console.log(`refreshSymbols())`)
        if (deadCounter-- < 0) throw ('stop')


        let i
        AMsymbols.sort(this.compareNames)
        for (i = 0; i < AMsymbols.length; i++)
            AMnames[i] = AMsymbols[i].input
    }

    define(oldstr: string, newstr: string) {
        console.log(`define(${oldstr},  ${newstr})`)
        if (deadCounter-- < 0) throw ('stop')

        AMsymbols.push({ input: oldstr, tag: "mo", output: newstr, tex: null, ttype: tokenType.DEFINITION })
        this.refreshSymbols() // this may be a problem if many symbols are defined!
    }

    AMremoveCharsAndBlanks(str: string, position: number): string {
        console.log(`AMremoveCharsAndBlanks(${str},  ${position})`)
        if (deadCounter-- < 0) throw ('stop')

        //remove n characters and any following blanks
        let st: string
        if (str.charAt(position) == "\\" && str.charAt(position + 1) != "\\" && str.charAt(position + 1) != " ")
            st = str.slice(position + 1)
        else
            st = str.slice(position)

        let i
        for (i = 0; i < st.length && st.charCodeAt(i) <= 32; i++) {
            // loop until we hit a non-whitespace
        }
        return st.slice(i)
    }


    /**  return position >=n where str appears or would be inserted  */
    position(AMnames: string[], str: string, n: number): number {
        console.log(`position(  ${str}),   ${n}`)
        if (deadCounter-- < 0) throw ('stop')


        // assumes arr is sorted
        if (n == 0) {
            let m
            n = -1
            let h = AMnames.length
            while (n + 1 < h) {
                m = (n + h) >> 1
                if (AMnames[m] < str)
                    n = m
                else
                    h = m
            }
            return h
        } else {
            let i
            for (i = n; i < AMnames.length && AMnames[i] < str; i++) {
                // hunt for first non-whitespace
            }
            return i // i=arr.length || arr[i]>=str
        }
    }

    AMgetSymbol(str: string): AMSymbol {
        // console.log(`AMgetSymbol(${str})`)
        // if (deadCounter-- < 0) throw ('stop')


        //return maximal initial substring of str that appears in names
        //return null if there is none
        let k = 0 //new pos
        let j = 0 //old pos
        let mk //match pos
        let st
        let tagst
        let match = ""
        let more = true
        for (var i = 1; i <= str.length && more; i++) {
            st = str.slice(0, i) //initial substring of length i
            j = k
            k = this.position(AMnames, st, j)
            if (k < AMnames.length && str.slice(0, AMnames[k].length) == AMnames[k]) {
                match = AMnames[k]
                mk = k
                i = match.length
            }
            more = k < AMnames.length && str.slice(0, AMnames[k].length) >= AMnames[k]
        }
        AMpreviousSymbol = AMcurrentSymbol
        if (match != "") {
            AMcurrentSymbol = AMsymbols[mk].ttype
            return AMsymbols[mk]
        }
        // if str[0] is a digit or - return maxsubstring of digits.digits
        AMcurrentSymbol = tokenType.CONST
        k = 1
        st = str.slice(0, 1)
        let integ = true
        while ("0" <= st && st <= "9" && k <= str.length) {
            st = str.slice(k, k + 1)
            k++
        }
        if (st == decimalsign) {
            st = str.slice(k, k + 1)
            if ("0" <= st && st <= "9") {
                integ = false
                k++
                while ("0" <= st && st <= "9" && k <= str.length) {
                    st = str.slice(k, k + 1)
                    k++
                }
            }
        }
        if ((integ && k > 1) || k > 2) {
            st = str.slice(0, k - 1)
            tagst = "mn"
        } else {
            k = 2
            st = str.slice(0, 1) //take 1 character
            tagst = (("A" > st || st > "Z") && ("a" > st || st > "z") ? "mo" : "mi")
        }
        if (st == "-" && str.charAt(1) !== ' ' && AMpreviousSymbol == tokenType.INFIX) {
            AMcurrentSymbol = tokenType.INFIX  //trick "/" into recognizing "-" on second parse
            return { input: st, tag: tagst, tex: null, output: st, ttype: tokenType.UNARY, func: true }
        }
        return { input: st, tag: tagst, tex: null, output: st, ttype: tokenType.CONST }
    }

    AMremoveBrackets(node) {
        let st
        if (!node.hasChildNodes()) { return }
        if (node.firstChild.hasChildNodes() && (node.nodeName == "mrow" || node.nodeName == "M:MROW")) {
            if (node.firstChild.nextSibling && node.firstChild.nextSibling.nodeName == "mtable") { return }
            st = node.firstChild.firstChild.nodeValue
            if (st == "(" || st == "[" || st == "{") node.removeChild(node.firstChild)
        }
        if (node.lastChild.hasChildNodes() && (node.nodeName == "mrow" || node.nodeName == "M:MROW")) {
            st = node.lastChild.firstChild.nodeValue
            if (st == ")" || st == "]" || st == "}") node.removeChild(node.lastChild)
        }
    }

    /*Parsing ASCII math expressions with the following grammar
    v ::= [A-Za-z] | greek letters | numbers | other constant symbols
    u ::= sqrt | text | bb | other unary symbols for font commands
    b ::= frac | root | stackrel         binary symbols
    l ::= ( | [ | { | (: | {:            left brackets
    r ::= ) | ] | } | :) | :}            right brackets
    S ::= v | lEr | uS | bSS             Simple expression
    I ::= S_S | S^S | S_S^S | S          Intermediate expression
    E ::= IE | I/I                       Expression
    Each terminal symbol is translated into a corresponding mathml node.*/


    AMparseSexpr(str: string): [Node, string] { //parses str and returns [node,tailstr]
        console.log(`AMparseSexpr(${str})`)
        if (deadCounter-- < 0) throw ('stop')

        let node, result, i, st// rightvert = false,

        let newFrag = document.createDocumentFragment()
        str = this.AMremoveCharsAndBlanks(str, 0)
        let symbol = this.AMgetSymbol(str)             //either a token or a bracket or empty

        if (symbol == null || symbol.ttype == tokenType.RIGHTBRACKET && AMnestingDepth > 0) {
            return [null, str]
        }
        if (symbol.ttype == tokenType.DEFINITION) {
            str = symbol.output + this.AMremoveCharsAndBlanks(str, symbol.input.length)
            symbol = this.AMgetSymbol(str)
        }
        switch (symbol.ttype) {
            case tokenType.UNDEROVER:
            case tokenType.CONST:
                str = this.AMremoveCharsAndBlanks(str, symbol.input.length)
                return [this.createMmlNode(symbol.tag,        //its a constant
                    document.createTextNode(symbol.output)), str]
            case tokenType.LEFTBRACKET:   //read (expr+)
                AMnestingDepth++
                str = this.AMremoveCharsAndBlanks(str, symbol.input.length)
                result = this.AMparseExpr(str, true)
                AMnestingDepth--
                if (typeof symbol.invisible == "boolean" && symbol.invisible)
                    node = this.createMmlNode("mrow", result[0])
                else {
                    node = this.createMmlNode("mo", document.createTextNode(symbol.output))
                    node = this.createMmlNode("mrow", node)
                    node.appendChild(result[0])

                }
                return [node, result[1]]
            case tokenType.TEXT:
                if (symbol != AMquote) str = this.AMremoveCharsAndBlanks(str, symbol.input.length)
                if (str.charAt(0) == "{") i = str.indexOf("}")
                else if (str.charAt(0) == "(") i = str.indexOf(")")
                else if (str.charAt(0) == "[") i = str.indexOf("]")
                else if (symbol == AMquote) i = str.slice(1).indexOf("\"") + 1
                else i = 0
                if (i == -1) i = str.length
                st = str.slice(1, i)
                if (st.charAt(0) == " ") {
                    node = this.createMmlNode("mspace")
                    node.setAttribute("width", "1ex")
                    newFrag.appendChild(node)
                }
                newFrag.appendChild(
                    this.createMmlNode(symbol.tag, document.createTextNode(st)))
                if (st.charAt(st.length - 1) == " ") {
                    node = this.createMmlNode("mspace")
                    node.setAttribute("width", "1ex")
                    newFrag.appendChild(node)
                }
                str = this.AMremoveCharsAndBlanks(str, i + 1)
                return [this.createMmlNode("mrow", newFrag), str]

            case tokenType.UNARYUNDEROVER:
            case tokenType.UNARY:
                str = this.AMremoveCharsAndBlanks(str, symbol.input.length)
                result = this.AMparseSexpr(str)

                if (result[0] == null) {
                    if (symbol.tag == "mi" || symbol.tag == "mo") {
                        return [this.createMmlNode(symbol.tag,
                            document.createTextNode(symbol.output)), str]
                    } else {
                        result[0] = this.createMmlNode("mi", "")
                    }
                }
                if (typeof symbol.func == "boolean" && symbol.func) { // functions hack
                    st = str.charAt(0)
                    if (st == "^" || st == "_" || st == "/" || st == "|" || st == "," ||
                        (symbol.input.length == 1 && symbol.input.match(/\w/) && st != "(")) {
                        return [this.createMmlNode(symbol.tag,
                            document.createTextNode(symbol.output)), str]
                    } else {
                        node = this.createMmlNode("mrow",
                            this.createMmlNode(symbol.tag, document.createTextNode(symbol.output)))
                        node.appendChild(result[0])
                        return [node, result[1]]
                    }
                }
                this.AMremoveBrackets(result[0])
                if (symbol.input == "sqrt") {           // sqrt
                    return [this.createMmlNode(symbol.tag, result[0]), result[1]]
                } else if (typeof symbol.rewriteleftright != "undefined") {    // abs, floor, ceil
                    node = this.createMmlNode("mrow", this.createMmlNode("mo", document.createTextNode(symbol.rewriteleftright[0])))
                    node.appendChild(result[0])
                    node.appendChild(this.createMmlNode("mo", document.createTextNode(symbol.rewriteleftright[1])))
                    return [node, result[1]]
                } else if (symbol.input == "cancel") {   // cancel
                    node = this.createMmlNode(symbol.tag, result[0])
                    node.setAttribute("notation", "updiagonalstrike")
                    return [node, result[1]]
                } else if (typeof symbol.acc == "boolean" && symbol.acc) {   // accent
                    node = this.createMmlNode(symbol.tag, result[0])
                    let accnode = this.createMmlNode("mo", document.createTextNode(symbol.output))
                    if (symbol.input == "vec" && (
                        (result[0].nodeName == "mrow" && result[0].childNodes.length == 1
                            && result[0].firstChild.firstChild.nodeValue !== null
                            && result[0].firstChild.firstChild.nodeValue.length == 1) ||
                        (result[0].firstChild.nodeValue !== null
                            && result[0].firstChild.nodeValue.length == 1))) {
                        accnode.setAttribute("stretchy", "false")
                    }
                    node.appendChild(accnode)
                    return [node, result[1]]
                } else {                        // font change command
                    if (typeof symbol.codes != "undefined") {
                        for (i = 0; i < result[0].childNodes.length; i++)
                            if (result[0].childNodes[i].nodeName == "mi" || result[0].nodeName == "mi") {
                                st = (result[0].nodeName == "mi" ? result[0].firstChild.nodeValue :
                                    result[0].childNodes[i].firstChild.nodeValue)
                                let newst: string
                                for (let j = 0; j < st.length; j++)
                                    if (st.charCodeAt(j) > 64 && st.charCodeAt(j) < 91)
                                        newst = newst + symbol.codes[st.charCodeAt(j) - 65]
                                    else if (st.charCodeAt(j) > 96 && st.charCodeAt(j) < 123)
                                        newst = newst + symbol.codes[st.charCodeAt(j) - 71]
                                    else newst = newst + st.charAt(j)
                                if (result[0].nodeName == "mi") {
                                    result[0] = this.createMmlNode("mo").
                                        appendChild(document.createTextNode(newst))
                                    console.log('%cadding mo:', 'background-color:green;', newst)
                                }
                                else {
                                    result[0].replaceChild(this.createMmlNode("mo").
                                        appendChild(document.createTextNode(newst)),
                                        result[0].childNodes[i])
                                }
                            }
                    }
                    node = this.createMmlNode(symbol.tag, result[0])
                    node.setAttribute(symbol.atname, symbol.atval)
                    return [node, result[1]]
                }
            case tokenType.BINARY:
                str = this.AMremoveCharsAndBlanks(str, symbol.input.length)
                result = this.AMparseSexpr(str)
                if (result[0] == null) return [this.createMmlNode("mo",
                    document.createTextNode(symbol.input)), str]
                this.AMremoveBrackets(result[0])
                let result2 = this.AMparseSexpr(result[1])
                if (result2[0] == null) return [this.createMmlNode("mo",
                    document.createTextNode(symbol.input)), str]
                this.AMremoveBrackets(result2[0])
                if (['color', 'class', 'id'].indexOf(symbol.input) >= 0) {

                    // Get the second argument
                    if (str.charAt(0) == "{") i = str.indexOf("}")
                    else if (str.charAt(0) == "(") i = str.indexOf(")")
                    else if (str.charAt(0) == "[") i = str.indexOf("]")
                    st = str.slice(1, i)

                    // Make a mathml node
                    node = this.createMmlNode(symbol.tag, result2[0])

                    // Set the correct attribute
                    if (symbol.input === "color") node.setAttribute("mathcolor", st)
                    else if (symbol.input === "class") node.setAttribute("class", st)
                    else if (symbol.input === "id") node.setAttribute("id", st)
                    return [node, result2[1]]
                }
                if (symbol.input == "root" || symbol.output == "stackrel")
                    newFrag.appendChild(result2[0])
                newFrag.appendChild(result[0])
                if (symbol.input == "frac") newFrag.appendChild(result2[0])
                return [this.createMmlNode(symbol.tag, newFrag), result2[1]]
            case tokenType.INFIX:
                str = this.AMremoveCharsAndBlanks(str, symbol.input.length)
                return [this.createMmlNode("mo", document.createTextNode(symbol.output)), str]
            case tokenType.SPACE:
                str = this.AMremoveCharsAndBlanks(str, symbol.input.length)
                node = this.createMmlNode("mspace")
                node.setAttribute("width", "1ex")
                newFrag.appendChild(node)
                newFrag.appendChild(
                    this.createMmlNode(symbol.tag, document.createTextNode(symbol.output)))
                node = this.createMmlNode("mspace")
                node.setAttribute("width", "1ex")
                newFrag.appendChild(node)
                return [this.createMmlNode("mrow", newFrag), str]
            case tokenType.LEFTRIGHT:
                //    if (rightvert) return [null,str] else rightvert = true
                AMnestingDepth++
                str = this.AMremoveCharsAndBlanks(str, symbol.input.length)
                result = this.AMparseExpr(str, false)
                AMnestingDepth--
                st = ""
                if (result[0].lastChild != null)
                    st = result[0].lastChild.firstChild.nodeValue
                if (st == "|" && str.charAt(0) !== ",") { // its an absolute value subterm
                    node = this.createMmlNode("mo", document.createTextNode(symbol.output))
                    node = this.createMmlNode("mrow", node)
                    node.appendChild(result[0])
                    return [node, result[1]]
                } else { // the "|" is a \mid so use unicode 2223 (divides) for spacing
                    node = this.createMmlNode("mo", document.createTextNode("\u2223"))
                    node = this.createMmlNode("mrow", node)
                    return [node, str]
                }
            default:
                //alert("default")
                str = this.AMremoveCharsAndBlanks(str, symbol.input.length)
                return [this.createMmlNode(symbol.tag,        //its a constant
                    document.createTextNode(symbol.output)), str]
        }
    }

    AMparseIexpr(str: string): [Node, string] {
        console.log(`AMparseIexpr(${str})`)
        if (deadCounter-- < 0) throw ('stop')

        let symbol, sym1, sym2, underover
        str = this.AMremoveCharsAndBlanks(str, 0)
        sym1 = this.AMgetSymbol(str)
        let result = this.AMparseSexpr(str)
        let node: Node = result[0]
        str = result[1]
        symbol = this.AMgetSymbol(str)
        if (symbol.ttype == tokenType.INFIX && symbol.input != "/") {
            str = this.AMremoveCharsAndBlanks(str, symbol.input.length)
            //    if (symbol.input == "/") result = AMparseIexpr(str) else ...
            result = this.AMparseSexpr(str)
            if (result[0] == null) // show box in place of missing argument
                result[0] = this.createMmlNode("mo", document.createTextNode("\u25A1"))
            else this.AMremoveBrackets(result[0])
            str = result[1]
            //    if (symbol.input == "/") AMremoveBrackets(node)
            underover = (sym1.ttype == tokenType.UNDEROVER || sym1.ttype == tokenType.UNARYUNDEROVER)
            if (symbol.input == "_") {
                sym2 = this.AMgetSymbol(str)
                if (sym2.input == "^") {
                    str = this.AMremoveCharsAndBlanks(str, sym2.input.length)
                    let res2 = this.AMparseSexpr(str)
                    this.AMremoveBrackets(res2[0])
                    str = res2[1]
                    node = this.createMmlNode((underover ? "munderover" : "msubsup"), node)
                    node.appendChild(result[0])
                    node.appendChild(res2[0])
                    node = this.createMmlNode("mrow", node) // so sum does not stretch
                } else {
                    node = this.createMmlNode((underover ? "munder" : "msub"), node)
                    node.appendChild(result[0])
                }
            } else if (symbol.input == "^" && underover) {
                node = this.createMmlNode("mover", node)
                node.appendChild(result[0])
            } else {
                node = this.createMmlNode(symbol.tag, node)
                node.appendChild(result[0])
            }
            if (typeof sym1.func != 'undefined' && sym1.func) {
                sym2 = this.AMgetSymbol(str)
                if (sym2.ttype != tokenType.INFIX && sym2.ttype != tokenType.RIGHTBRACKET &&
                    (sym1.input.length > 1 || sym2.ttype == tokenType.LEFTBRACKET)) {
                    result = this.AMparseIexpr(str)
                    node = this.createMmlNode("mrow", node)
                    node.appendChild(result[0])
                    str = result[1]
                }
            }
        }
        return [node, str]
    }

    AMparseExpr(str: string, startRightbracket: boolean) {
        console.log(`AMparseExpr(${str},  ${startRightbracket})`)
        if (deadCounter-- < 0) throw ('stop')

        let symbol
        let result
        let node
        let newFrag = document.createDocumentFragment()
        do {
            str = this.AMremoveCharsAndBlanks(str, 0)
            result = this.AMparseIexpr(str)
            node = result[0]
            str = result[1]
            symbol = this.AMgetSymbol(str)
            if (symbol.ttype == tokenType.INFIX && symbol.input == "/") {
                str = this.AMremoveCharsAndBlanks(str, symbol.input.length)
                result = this.AMparseIexpr(str)
                if (result[0] == null) // show box in place of missing argument
                    result[0] = this.createMmlNode("mo", document.createTextNode("\u25A1"))
                else this.AMremoveBrackets(result[0])
                str = result[1]
                this.AMremoveBrackets(node)
                node = this.createMmlNode(symbol.tag, node)
                node.appendChild(result[0])
                newFrag.appendChild(node)
                symbol = this.AMgetSymbol(str)
            }
            else if (node != undefined) newFrag.appendChild(node)
        } while ((symbol.ttype != tokenType.RIGHTBRACKET &&
            (symbol.ttype != tokenType.LEFTRIGHT || startRightbracket)
            || AMnestingDepth == 0) && symbol != null && symbol.output != "")


        if (symbol.ttype == tokenType.RIGHTBRACKET || symbol.ttype == tokenType.LEFTRIGHT) {
            //    if (AMnestingDepth > 0) AMnestingDepth--
            let len = newFrag.childNodes.length
            if (len > 0 && newFrag.childNodes[len - 1].nodeName == "mrow"
                && newFrag.childNodes[len - 1].lastChild
                && newFrag.childNodes[len - 1].lastChild.firstChild) { //matrix
                //removed to allow row vectors: //&& len>1 &&
                //newFrag.childNodes[len-2].nodeName == "mo" &&
                //newFrag.childNodes[len-2].firstChild.nodeValue == ","
                let right = newFrag.childNodes[len - 1].lastChild.firstChild.nodeValue
                if (right == ")" || right == "]") {
                    let left = newFrag.childNodes[len - 1].firstChild.firstChild.nodeValue
                    if (left == "(" && right == ")" && symbol.output != "}" ||
                        left == "[" && right == "]") {
                        let pos = [] // positions of commas
                        let matrix = true
                        let m = newFrag.childNodes.length
                        for (let i = 0; matrix && i < m; i = i + 2) {
                            pos[i] = []
                            node = newFrag.childNodes[i]
                            if (matrix) matrix = node.nodeName == "mrow" &&
                                (i == m - 1 || node.nextSibling.nodeName == "mo" &&
                                    node.nextSibling.firstChild.nodeValue == ",") &&
                                node.firstChild.firstChild &&
                                node.firstChild.firstChild.nodeValue == left &&
                                node.lastChild.firstChild &&
                                node.lastChild.firstChild.nodeValue == right
                            if (matrix)
                                for (var j = 0; j < node.childNodes.length; j++)
                                    if (node.childNodes[j].firstChild.nodeValue == ",")
                                        pos[i][pos[i].length] = j
                            if (matrix && i > 1) matrix = pos[i].length == pos[i - 2].length
                        }
                        matrix = matrix && (pos.length > 1 || pos[0].length > 0)
                        let columnlines = []
                        if (matrix) {
                            let row, frag, n, k, table = document.createDocumentFragment()
                            for (let i = 0; i < m; i = i + 2) {
                                row = document.createDocumentFragment()
                                frag = document.createDocumentFragment()
                                node = newFrag.firstChild // <mrow>(-,-,...,-,-)</mrow>
                                n = node.childNodes.length
                                k = 0
                                node.removeChild(node.firstChild) //remove (
                                for (j = 1; j < n - 1; j++) {
                                    if (typeof pos[i][k] != "undefined" && j == pos[i][k]) {
                                        node.removeChild(node.firstChild) //remove ,
                                        if (node.firstChild.nodeName == "mrow" && node.firstChild.childNodes.length == 1 &&
                                            node.firstChild.firstChild.firstChild.nodeValue == "\u2223") {
                                            //is columnline marker - skip it
                                            if (i == 0) { columnlines.push("solid") }
                                            node.removeChild(node.firstChild) //remove mrow
                                            node.removeChild(node.firstChild) //remove ,
                                            j += 2
                                            k++
                                        } else if (i == 0) { columnlines.push("none") }
                                        row.appendChild(this.createMmlNode("mtd", frag))
                                        k++
                                    } else
                                        frag.appendChild(node.firstChild)
                                }
                                row.appendChild(this.createMmlNode("mtd", frag))
                                if (i == 0) { columnlines.push("none") }
                                if (newFrag.childNodes.length > 2) {
                                    newFrag.removeChild(newFrag.firstChild) //remove <mrow>)</mrow>
                                    newFrag.removeChild(newFrag.firstChild) //remove <mo>,</mo>
                                }
                                table.appendChild(this.createMmlNode("mtr", row))
                            }
                            node = this.createMmlNode("mtable", table)
                            node.setAttribute("columnlines", columnlines.join(" "))
                            if (typeof symbol.invisible == "boolean" && symbol.invisible) node.setAttribute("columnalign", "left")
                            newFrag.replaceChild(node, newFrag.firstChild)
                        }
                    }
                }
            }
            str = this.AMremoveCharsAndBlanks(str, symbol.input.length)
            if (typeof symbol.invisible != "boolean" || !symbol.invisible) {
                node = this.createMmlNode("mo", document.createTextNode(symbol.output))
                newFrag.appendChild(node)
            }
        }
        return [newFrag, str]
    }

    parseMath(str: string) {
        console.log(`parseMath(${str})`)
        if (deadCounter-- < 0) throw ('stop')


        AMnestingDepth = 0
        //some basic cleanup for dealing with stuff editors like TinyMCE adds
        str = str.replace(/&nbsp/g, "")
        str = str.replace(/&gt/g, ">")
        str = str.replace(/&lt/g, "<")
        let frag = this.AMparseExpr(str.replace(/^\s+/g, ""), false)[0]
        let node = this.createMmlNode("mstyle", frag)
        if (mathcolor != "") node.setAttribute("mathcolor", mathcolor)
        if (mathfontsize != "") {
            node.setAttribute("fontsize", mathfontsize)
            node.setAttribute("mathsize", mathfontsize)
        }
        if (mathfontfamily != "") {
            node.setAttribute("fontfamily", mathfontfamily)
            node.setAttribute("mathvariant", mathfontfamily)
        }

        if (displaystyle) node.setAttribute("displaystyle", "true")
        node = this.createMmlNode("math", node)
        if (showasciiformulaonhover)                      //fixed by djhsu so newline
            node.setAttribute("title", str.replace(/\s+/g, " "))//does not show in Gecko
        return node
    }


    /** I don't think this ever gets called. it is something to do with documenting the math */
    strarr2docFrag(arr: string[], linebreaks): DocumentFragment {
        console.log(`strarr2docFrag(${arr})`)
        if (deadCounter-- < 0) throw ('stop')

        let newFrag = document.createDocumentFragment()
        let expr = false
        for (let i = 0; i < arr.length; i++) {
            if (expr) newFrag.appendChild(this.parseMath(arr[i]))
            else {
                let arri = (linebreaks ? arr[i].split("\n\n") : [arr[i]])
                newFrag.appendChild(this.createElementXHTML("span").
                    appendChild(document.createTextNode(arri[0])))
                for (let j = 1; j < arri.length; j++) {
                    newFrag.appendChild(this.createElementXHTML("p"))
                    newFrag.appendChild(this.createElementXHTML("span").
                        appendChild(document.createTextNode(arri[j])))
                }
            }
            expr = !expr
        }
        return newFrag
    }

    AMautomathrec(str: string): string {
        console.log(`AMautomathrec(${str})`)
        if (deadCounter-- < 0) throw ('stop')

        //formula is a space (or start of str) followed by a maximal sequence of *two* or more tokens, possibly separated by runs of digits and/or space.
        //tokens are single letters (except a, A, I) and ASCIIMathML tokens
        let texcommand = "\\\\[a-zA-Z]+|\\\\\\s|"
        let ambigAMtoken = "\\b(?:oo|lim|ln|int|oint|del|grad|aleph|prod|prop|sinh|cosh|tanh|cos|sec|pi|tt|fr|sf|sube|supe|sub|sup|det|mod|gcd|lcm|min|max|vec|ddot|ul|chi|eta|nu|mu)(?![a-z])|"
        let englishAMtoken = "\\b(?:sum|ox|log|sin|tan|dim|hat|bar|dot)(?![a-z])|"
        let secondenglishAMtoken = "|\\bI\\b|\\bin\\b|\\btext\\b" // took if and or not out
        let simpleAMtoken = "NN|ZZ|QQ|RR|CC|TT|AA|EE|sqrt|dx|dy|dz|dt|xx|vv|uu|nn|bb|cc|csc|cot|alpha|beta|delta|Delta|epsilon|gamma|Gamma|kappa|lambda|Lambda|omega|phi|Phi|Pi|psi|Psi|rho|sigma|Sigma|tau|theta|Theta|xi|Xi|zeta" // uuu nnn?
        let letter = "[a-zA-HJ-Z](?=(?:[^a-zA-Z]|$|" + ambigAMtoken + englishAMtoken + simpleAMtoken + "))|"
        let token = letter + texcommand + "\\d+|[-()[\\]{}+=*&^_%\\\@/<>,\\|!:'~]|\\.(?!(?:\x20|$))|" + ambigAMtoken + englishAMtoken + simpleAMtoken
        let re = new RegExp("(^|\\s)(((" + token + ")\\s?)((" + token + secondenglishAMtoken + ")\\s?)+)([,.?]?(?=\\s|$))", "g")
        str = str.replace(re, " `$2`$7")
        let arr = str.split(AMdelimiter1)
        let re1 = new RegExp("(^|\\s)([b-zB-HJ-Z+*<>]|" + texcommand + ambigAMtoken + simpleAMtoken + ")(\\s|\\n|$)", "g")
        let re2 = new RegExp("(^|\\s)([a-z]|" + texcommand + ambigAMtoken + simpleAMtoken + ")([,.])", "g") // removed |\d+ for now
        for (let i = 0; i < arr.length; i++)   //single nonenglish tokens
            if (i % 2 == 0) {
                arr[i] = arr[i].replace(re1, " `$2`$3")
                arr[i] = arr[i].replace(re2, " `$2`$3")
                arr[i] = arr[i].replace(/([{}[\]])/, "`$1`")
            }
        str = arr.join(AMdelimiter1)
        str = str.replace(/((^|\s)\([a-zA-Z]{2,}.*?)\)`/g, "$1`)")  //fix parentheses
        str = str.replace(/`(\((a\s|in\s))(.*?[a-zA-Z]{2,}\))/g, "$1`$3")  //fix parentheses
        str = str.replace(/\sin`/g, "` in")
        str = str.replace(/`(\(\w\)[,.]?(\s|\n|$))/g, "$1`")
        str = str.replace(/`([0-9.]+|e.g|i.e)`(\.?)/gi, "$1$2")
        str = str.replace(/`([0-9.]+:)`/g, "$1")
        return str
    }

    processNodeR(n: Node, linebreaks: boolean): number {
        console.log(`processNodeR(${n},  ${linebreaks})`)
        if (deadCounter-- < 0) throw ('stop')

        let mtch, str, arr, frg, i
        if (n.childNodes.length == 0) {
            if ((n.nodeType != COMMENT_NODE || linebreaks) &&
                n.parentNode.nodeName != "form" && n.parentNode.nodeName != "FORM" &&
                n.parentNode.nodeName != "textarea" && n.parentNode.nodeName != "TEXTAREA" /*&&
    n.parentNode.nodeName!="pre" && n.parentNode.nodeName!="PRE"*/) {
                str = n.nodeValue
                if (!(str == null)) {
                    str = str.replace(/\r\n\r\n/g, "\n\n")
                    str = str.replace(/\x20+/g, " ")
                    str = str.replace(/\s*\r\n/g, " ")
                    mtch = false

                    str = str.replace(new RegExp(AMescape1, "g"),
                        function () { mtch = true; return "AMescape1" })
                    str = str.replace(/\\?end{?a?math}?/i,
                        function () { automathrecognize = false; mtch = true; return "" })
                    str = str.replace(/amath\b|\\begin{a?math}/i,
                        function () { automathrecognize = true; mtch = true; return "" })
                    arr = str.split(AMdelimiter1)
                    if (automathrecognize)
                        for (i = 0; i < arr.length; i++)
                            if (i % 2 == 0)
                                arr[i] = this.AMautomathrec(arr[i])
                    str = arr.join(AMdelimiter1)
                    arr = str.split(AMdelimiter1)
                    for (i = 0; i < arr.length; i++) // this is a problem ************
                        arr[i] = arr[i].replace(/AMescape1/g, AMdelimiter1)

                    if (arr.length > 1 || mtch) {
                        if (!this.noMathMl) {
                            frg = this.strarr2docFrag(arr, n.nodeType == COMMENT_NODE)
                            let len = frg.childNodes.length
                            n.parentNode.replaceChild(frg, n)
                            return len - 1
                        } else return 0
                    }
                }
            } else return 0
        } else if (n.nodeName != "math") {
            for (i = 0; i < n.childNodes.length; i++)
                i += this.processNodeR(n.childNodes[i], linebreaks)
        }
        return 0
    }


    // removed, 
    // AMprocessNode(n, linebreaks, spanclassAM) {
    //     let frag, st
    //     if (spanclassAM != null) {
    //         frag = document.getElementsByTagName("span")
    //         for (var i = 0 i < frag.length i++)
    //             if (frag[i].className == "AM")
    //                 processNodeR(frag[i], linebreaks, false)
    //     } else {
    //         try {
    //             st = n.innerHTML // look for AMdelimiter on page
    //         } catch (err) { }
    //         //alert(st)
    //         if (st == null || /amath\b|\\begin{a?math}/i.test(st) ||
    //             st.indexOf(AMdelimiter1 + " ") != -1 || st.slice(-1) == AMdelimiter1 ||
    //             st.indexOf(AMdelimiter1 + "<") != -1 || st.indexOf(AMdelimiter1 + "\n") != -1) {
    //             processNodeR(n, linebreaks, false)
    //         }
    //     }
    // }



}