declare namespace TSX {
    /** JXG.Composition */
    interface CompositionAttributes {
    }
    /** This is the basic class for geometry elements like points, circles and lines. */
    interface GeometryElementAttributes {
        /** Determines the elements border-style. Possible values are: 0 for a solid line 1 for a dotted line 2 for a line with small dashes 3 for a line with medium dashes
       /* 4 for a line with big dashes 5 for a line with alternating medium and big dashes and large gaps 6 for a line with alternating medium and big dashes and small
       /* gaps 7 for a dotted line. Needs JXG.GeometryElement#linecap set to "round" for round dots.The dash patterns are defined in JXG.AbstractRenderer#dashArray. */
        dash?: Number;
        /** If true, the dash pattern is multiplied by strokeWidth / 2. */
        dashScale?: Boolean;
        /** If draft.draft: true the element will be drawn in grey scale colors (as default) to visualize that it's only a draft. */
        draft?: Object;
        /** If the element is dragged it will be moved on mousedown or touchstart to the top of its layer. Works only for SVG renderer and for simple elements consisting of
       /* one SVG node. */
        dragToTopOfLayer?: Boolean;
        /** The fill color of this geometry element. */
        fillColor?: String;
        /** Opacity for fill color. */
        fillOpacity?: Number;
        /** If true the element is fixed and can not be dragged around. The element will be repositioned on zoom and moveOrigin events. */
        fixed?: Boolean;
        /** If true the element is fixed and can not be dragged around. The element will even stay at its position on zoom and moveOrigin events. Only free elements like
       /* points, texts, curves can be frozen. */
        frozen?: Boolean;
        /** Gradient type. Possible values are 'linear'. 'radial' or null. */
        gradient?: String;
        /** Angle (in radians) of the gradiant in case the gradient is of type 'linear'. If the angle is 0, the first color is on the left and the second color is on the
       /* right. If the angle is &pi;/2 the first color is on top and the second color at the bottom. */
        gradientAngle?: Number;
        /** From the SVG specification: ‘cx’, ‘cy’ and ‘r’ define the largest (i.e., outermost) circle for the radial gradient. The gradient will be drawn such
       /* that the 100% gradient stop is mapped to the perimeter of this largest (i.e., outermost) circle. For radial gradients in canvas this is the value 'x1'. Takes a
       /* value between 0 and 1. */
        gradientCX?: Number;
        /** From the SVG specification: ‘cx’, ‘cy’ and ‘r’ define the largest (i.e., outermost) circle for the radial gradient. The gradient will be drawn such
       /* that the 100% gradient stop is mapped to the perimeter of this largest (i.e., outermost) circle. For radial gradients in canvas this is the value 'y1'. Takes a
       /* value between 0 and 1. */
        gradientCY?: Number;
        /** The gradientEndOffset attribute is a number (ranging from 0 to 1) which indicates where the second gradient stop is placed, see the SVG specification for more
       /* information. For linear gradients, this attribute represents a location along the gradient vector. For radial gradients, it represents a percentage distance
       /* from (fx,fy) to the edge of the outermost/largest circle. */
        gradientEndOffset?: Number;
        /** This attribute defines the radius of the start circle of the radial gradient. The gradient will be drawn such that the 0% &lt;stop&gt; is mapped to the
       /* perimeter of the start circle. For radial gradients in canvas this is the value 'r0'. Takes a value between 0 and 1. */
        gradientFR?: Number;
        /** ‘fx’ and ‘fy’ define the focal point for the radial gradient. The gradient will be drawn such that the 0% gradient stop is mapped to (fx, fy). For
       /* radial gradients in canvas this is the value 'x0'. Takes a value between 0 and 1. */
        gradientFX?: Number;
        /** y-coordinate of the circle center for the second color in case of gradient 'radial'. (The attribute fy in SVG) For radial gradients in canvas this is the value
       /* 'y0'. Takes a value between 0 and 1. */
        gradientFY?: Number;
        /** From the SVG specification: ‘cx’, ‘cy’ and ‘r’ define the largest (i.e., outermost) circle for the radial gradient. The gradient will be drawn such
       /* that the 100% gradient stop is mapped to the perimeter of this largest (i.e., outermost) circle. For radial gradients in canvas this is the value 'r1'. Takes a
       /* value between 0 and 1. */
        gradientR?: Number;
        /** Second color for gradient. */
        gradientSecondColor?: String;
        /** Opacity of second gradient color. Takes a value between 0 and 1. */
        gradientSecondOpacity?: Number;
        /** The gradientStartOffset attribute is a number (ranging from 0 to 1) which indicates where the first gradient stop is placed, see the SVG specification for more
       /* information. For linear gradients, this attribute represents a location along the gradient vector. For radial gradients, it represents a percentage distance
       /* from (fx,fy) to the edge of the outermost/largest circle. */
        gradientStartOffset?: Number;
        /**  */
        highlight?: Boolean;
        /** The fill color of the given geometry element when the mouse is pointed over it. */
        highlightFillColor?: String;
        /** Opacity for fill color when the object is highlighted. */
        highlightFillOpacity?: Number;
        /** The stroke color of the given geometry element when the user moves the mouse over it. */
        highlightStrokeColor?: String;
        /** Opacity for stroke color when the object is highlighted. */
        highlightStrokeOpacity?: Number;
        /** Width of the element's stroke when the mouse is pointed over it. */
        highlightStrokeWidth?: Number;
        /** Display layer which will contain the element. */
        layer?: String;
        /** Line endings (linecap) of a stroke element, i.e. line, circle, curve. Possible values are:'butt','round','square'.Not available for VML renderer. */
        lineCap?: String;
        /** If this is set to true, the element is updated in every update call of the board. If set to false, the element is updated only after zoom events or more
       /* generally, when the bounding box has been changed. Examples for the latter behavior should be axes. */
        needsRegularUpdate?: Boolean;
        /** Precision options for JSXGraph elements. This attributes takes either the value 'inherit' or an object of the form:precision: {touch: 30,mouse: 4,pen: 4 }In the
       /* first case, the global, JSXGraph-wide values of JXGraph.Options.precision are taken. */
        precision?: Object;
        /** A private element will be inaccessible in certain environments, e.g. a graphical user interface. */
        priv?: Boolean;
        /** Determines whether two-finger manipulation may rotate this object. If set to false, the object can only be scaled and translated.In case the element is a
       /* polygon or line and it has the attribute "rotatable:false", moving the element with two fingers results in a rotation or translation.If an element is set to be
       /* neither scalable nor rotatable, it can only be translated.In case of a polygon, scaling is only possible if no vertex has snapToGrid or snapToPoints enabled and
       /* no vertex is fixed by some other constraint. Also, the polygon itself has to have snapToGrid disabled. */
        rotatable?: Boolean;
        /** Determines whether two-finger manipulation of this object may change its size. If set to false, the object is only rotated and translated.In case the element is
       /* a horizontal or vertical line having ticks, "scalable:true" enables zooming of the board by dragging ticks lines. This feature is enabled, for the ticks element
       /* of the line element the attribute "fixed" has to be false and the line element's scalable attribute has to be true.In case the element is a polygon or line and
       /* it has the attribute "scalable:false", moving the element with two fingers results in a rotation or translation.If an element is set to be neither scalable nor
       /* rotatable, it can only be translated.In case of a polygon, scaling is only possible if no vertex has snapToGrid or snapToPoints enabled and no vertex is fixed
       /* by some other constraint. Also, the polygon itself has to have snapToGrid disabled. */
        scalable?: Boolean;
        /** If enabled:true the (stroke) element will get a customized shadow.Customize color and opacity: If the object's RGB stroke color is [r,g,b] and its opacity is
       /* op, and the shadow parameters color is given as [r', g', b'] and opacity as op' the shadow will receive the RGB color[blend*r + r', blend*g + g', blend*b +
       /* b']and its opacity will be equal to op * op'. Further, the parameters blur and offset can be adjusted.This attribute is only available with SVG, not with
       /* canvas. */
        shadow?: Object;
        /** Snaps the element or its parents to the grid. Currently only relevant for points, circles, and lines. Points are snapped to grid directly, on circles and lines
       /* it's only the parent points that are snapped */
        snapToGrid?: Boolean;
        /** The stroke color of the given geometry element. */
        strokeColor?: String;
        /** Opacity for element's stroke color. */
        strokeOpacity?: Number;
        /** Width of the element's stroke. */
        strokeWidth?: Number;
        /** Controls if an element can get the focus with the tab key. tabindex corresponds to the HTML attribute of the same name. See descriptiona at MDN. The additional
       /* value "null" completely disables focus of an element. The value will be ignored if keyboard control of the board is not enabled or the element is fixed or not
       /* visible. */
        tabindex?: Number;
        /** If true the element will be traced, i.e. on every movement the element will be copied to the background. Use JXG.GeometryElement#clearTrace to delete the trace
       /* elements.The calling of element.setAttribute({trace:false}) additionally deletes all traces of this element. By calling element.setAttribute({trace:'pause'})
       /* the removal of already existing traces can be prevented.The visual appearance of the trace can be influenced by JXG.GeometryElement#traceAttributes. */
        trace?: Boolean | String;
        /** Extra visual properties for traces of an element */
        traceAttributes?: Object;
        /** Transition duration (in milliseconds) for certain cahnges of properties like color and opacity. The properties can be set in the attribute transitionProperties
       /* Works in SVG renderer, only. */
        transitionDuration?: Number;
        /** Properties which change smoothly in the time set in transitionDuration. Possible values are ['fill', 'fill-opacity', 'stroke', 'stroke-opacity', 'stroke-width',
       /* 'width', 'height', 'rx', 'ry'] (and maybe more) for geometry elements and ['color', 'opacity', 'all'] for HTML texts. */
        transitionProperties?: String[];
        /** If false the element won't be visible on the board, otherwise it is shown. */
        visible?: Boolean;
        /** If true a label will display the element's name. */
        withLabel?: Boolean;
        /**  */
        color?: String;
        /**  */
        name?: String;
    }
    /** This element is used to provide a constructor for curve, which is just a wrapper for element Curve. A curve is a mapping from R to R^2. t mapsto (x(t),y(t)). The graph is drawn for t in the interval [a,b].The following types of curves can be plotted:parametric curves: t mapsto (x(t),y(t)), where x() and y() are univariate functions.polar curves: curves commonly written with polar equations like spirals and cardioids.data plots: plot line segments through a given list of coordinates. */
    interface CurveAttributes extends GeometryElementAttributes {
        /** The curveType is set in JXG.Curve#generateTerm and used in JXG.Curve#updateCurve. Possible values are'none' 'plot': Data plot 'parameter': we can not
       /* distinguish function graphs and parameter curves 'functiongraph': function graph 'polar' 'implicit' (not yet) Only parameter and plot are set directly. Polar is
       /* set with JXG.GeometryElement#setAttribute only. */
        curveType?: String;
        /** If true use a recursive bisection algorithm. It is slower, but usually the result is better. It tries to detect jumps and singularities. */
        doAdvancedPlot?: Boolean;
        /** If true use the algorithm by Gillam and Hohenwarter, which was default until version 0.98. */
        doAdvancedPlotOld?: Boolean;
        /** Configure arrow head at the start position for curve. Recommended arrow head type is 7. */
        firstArrow?: Boolean | Object;
        /** The data points of the curve are not connected with straight lines but with bezier curves. */
        handDrawing?: Boolean;
        /** Attributes for curve label. */
        label?: Label;
        /** Configure arrow head at the end position for curve. Recommended arrow head type is 7. */
        lastArrow?: Boolean | Object;
        /** Number of points used for plotting triggered by up events (i.e. high quality plotting) in case Curve#doAdvancedPlot is false. */
        numberPointsHigh?: Number;
        /** Number of points used for plotting triggered by move events (i.e. lower quality plotting but fast) in case Curve#doAdvancedPlot is false. */
        numberPointsLow?: Number;
        /** Select the version of the plot algorithm.Version 1 is very outdatedVersion 2 is the default version in JSXGraph v0.99.*, v1.0, and v1.1, v1.2.0Version 3 is an
       /* internal version that was never published ina stable version.Version 4 is available since JSXGraph v1.2.0Version 4 plots correctly logarithms if the function
       /* term is supplied as string (i.e. as JessieCode) */
        plotVersion?: Number;
        /** Apply Ramer-Douglas-Peuker smoothing. */
        RDPsmoothing?: Boolean;
        /** Recursion depth used for plotting triggered by up events (i.e. high quality plotting) in case Curve#doAdvancedPlot is true. */
        recursionDepthHigh?: Number;
        /** Number of points used for plotting triggered by move events in case (i.e. lower quality plotting but fast) Curve#doAdvancedPlot is true. */
        recursionDepthLow?: Number;
    }
    /** This element is used to provide a constructor for a general line. A general line is given by two points. By setting additional properties a line can be used as an arrow and/or axis. */
    interface LineAttributes extends GeometryElementAttributes {
        /** Configure the arrow head at the position of its first point or the corresponding intersection with the canvas borderIn case firstArrow is an object it has the
       /* sub-attributes:{type: 1, // possible values are 1, 2, ..., 7. Default value is 1.size: 6, // size of the arrow head. Default value is 6.// This value is
       /* multiplied with the strokeWidth of the line// Exception: for type=7 size is ignoredhighlightSize: 6, // size of the arrow head in case the element is
       /* highlighted. Default value }type=7 is the default for curves if firstArrow: true */
        firstArrow?: Boolean | Object;
        /** Attributes for the line label. */
        label?: Object;
        /** Configure the arrow head at the position of its second point or the corresponding intersection with the canvas border.In case lastArrow is an object it has the
       /* sub-attributes:{type: 1, // possible values are 1, 2, ..., 7. Default value is 1.size: 6, // size of the arrow head. Default value is 6.// This value is
       /* multiplied with the strokeWidth of the line.// Exception: for type=7 size is ignoredhighlightSize: 6, // size of the arrow head in case the element is
       /* highlighted. Default value is 6. }type=7 is the default for curves if lastArrow: true */
        lastArrow?: Boolean | Object;
        /** This number (pixel value) controls where infinite lines end at the canvas border. If zero, the line ends exactly at the border, if negative there is a margin to
       /* the inside, if positive the line ends outside of the canvas (which is invisible). */
        margin?: Number;
        /** Attributes for first defining point of the line. */
        point1?: Point;
        /** Attributes for second defining point of the line. */
        point2?: Point;
        /** Defines together with Point#snapSizeY the grid the point snaps on to. The point will only snap on integer multiples to snapSizeX in x and snapSizeY in y
       /* direction. If this value is equal to or less than 0, it will use the grid displayed by the major ticks of the default ticks of the default x axes of the board. */
        snapSizeX?: Number;
        /** Defines together with Point#snapSizeX the grid the point snaps on to. The point will only snap on integer multiples to snapSizeX in x and snapSizeY in y
       /* direction. If this value is equal to or less than 0, it will use the grid displayed by the major ticks of the default ticks of the default y axes of the board. */
        snapSizeY?: Number;
        /** If set to true, the point will snap to a grid defined by Point#snapSizeX and Point#snapSizeY. */
        snapToGrid?: Boolean;
        /** If true, line stretches infinitely in direction of its first point. Otherwise it ends at point1. */
        straightFirst?: Boolean;
        /** If true, line stretches infinitely in direction of its second point. Otherwise it ends at point2. */
        straightLast?: Boolean;
        /** Attributes for ticks of the line. */
        ticks?: Object;
        /** If set to true, Line#firstArrow is set to true and the point is visible, the arrow head will just touch the circle line of the start point of the line. */
        touchFirstPoint?: Boolean;
        /** If set to true, Line#lastArrow is set to true and the point is visible, the arrow head will just touch the circle line of the start point of the line. */
        touchLastPoint?: Boolean;
    }
    /** This element is used to provide a constructor for a general point. A free point is created if the given parent elements are all numbers and the property fixed is not set or set to false. If one or more parent elements is not a number but a string containing a GEONExT constraint or a function the point will be considered as constrained). That means that the user won't be able to change the point's position directly. */
    interface PointAttributes extends GeometryElementAttributes {
        /** If the distance of the point to one of its attractors is less than this number the point will be a glider on this attracting element. If set to zero nothing
       /* happens. */
        attractorDistance?: Number;
        /** List of attractor elements. If the distance of the point is less than attractorDistance the point is made to glider of this element. */
        attractors?: Element[];
        /** Unit for attractorDistance and snatchDistance, used for magnetized points and for snapToPoints. Possible values are 'screen' and 'user'. */
        attractorUnit?: String;
        /** If set to true, the point will only snap to (possibly invisibly) grid points when within Point#attractorDistance of such a grid point.The coordinates of the
       /* grid points are either integer multiples of snapSizeX and snapSizeY (given in user coordinates, not pixels) or are the intersection points of the major ticks of
       /* the boards default axes in case that snapSizeX, snapSizeY are negative. */
        attractToGrid?: Boolean;
        /** There are different point styles which differ in appearance. Posssible values are Value InputOutput crossx circleo square, [][] plus+ minus- divide|
       /* diamond&lt;&gt; triangleup^, a, A triangledownv triangleleft&lt; triangleright&gt; */
        face?: String;
        /** List of elements which are ignored by snapToPoints. */
        ignoredSnapToPoints?: Element[];
        /** Truncating rule for the digits in the infobox.'auto': done automatically by JXG.autoDigits() 'none': no truncation number: truncate after "number digits" with
       /* JXG.toFixed() */
        infoboxDigits?: String | Number;
        /** If true, the infobox is shown on mouse/pen over, if false not. If the value is 'inherit', the value of JXG.Board#showInfobox is taken. true | false | 'inherit' */
        showInfobox?: Boolean | String;
        /** Size of a point, either in pixel or user coordinates. Means radius resp. half the width of a point (depending on the face). */
        size?: Number;
        /** Unit for size. Possible values are 'screen' and 'user. */
        sizeUnit?: String;
        /** Defines together with Point#snapSizeY the grid the point snaps on to. It is given in user coordinates, not in pixels. The point will only snap on integer
       /* multiples to snapSizeX in x and snapSizeY in y direction. If this value is equal to or less than 0, it will use the grid displayed by the major ticks of the
       /* default ticks of the default x axes of the board. */
        snapSizeX?: Number;
        /** Defines together with Point#snapSizeX the grid the point snaps on to. It is given in user coordinates, not in pixels. The point will only snap on integer
       /* multiples to snapSizeX in x and snapSizeY in y direction. If this value is equal to or less than 0, it will use the grid displayed by the major ticks of the
       /* default ticks of the default y axes of the board. */
        snapSizeY?: Number;
        /** If set to true, the point will snap to a grid of integer multiples of Point#snapSizeX and Point#snapSizeY (in user coordinates).The coordinates of the grid
       /* points are either integer multiples of snapSizeX and snapSizeY (given in user coordinates, not pixels) or are the intersection points of the major ticks of the
       /* boards default axes in case that snapSizeX, snapSizeY are negative. */
        snapToGrid?: Boolean;
        /** If set to true, the point will snap to the nearest point in distance of Point#attractorDistance. */
        snapToPoints?: Boolean;
        /** If the distance of the point to one of its attractors is at least this number the point will be released from being a glider on the attracting element. If set
       /* to zero nothing happens. */
        snatchDistance?: Number;
        /** This attribute was used to determined the point layout. It was derived from GEONExT and was replaced by Point#face and Point#size. */
        style?: Number;
        /** If true, the point size changes on zoom events. */
        zoom?: Boolean;
    }
    /** Construct and handle texts.The coordinates can either be abslute (i.e. respective to the coordinate system of the board) or be relative to the coordinates of an element given in Text#anchor.HTML, MathJaX, KaTeX and GEONExT syntax can be handled.There are two ways to display texts:using the text element of the renderer (canvas or svg). In most cases this is the suitable approach if speed matters. However, advanced rendering like MathJax, KaTeX or HTML/CSS are not possible.using HTML &lt;div&gt;. This is the most flexible approach. The drawback is that HTML can only be display "above" the geometry elements. If HTML should be displayed in an inbetween layer, conder to use an element of type ForeignObject (available in svg renderer, only). */
    interface TextAttributes extends GeometryElementAttributes {
        /** Anchor element Point, Text or Image of the text. If it exists, the coordinates of the text are relative to this anchor element. In this case, only numbers are
       /* possible coordinates, functions are not supported. */
        anchor?: Object;
        /** The horizontal alignment of the text. Possible values include 'auto, 'left', 'middle', and 'right'. */
        anchorX?: String;
        /** The vertical alignment of the text. Possible values include 'auto, 'top', 'middle', and 'bottom'. For MathJax or KaTeX, 'top' is recommended. */
        anchorY?: String;
        /** List of attractor elements. If the distance of the text is less than attractorDistance the text is made to glider of this element. */
        attractors?: Element[];
        /** CSS class of the text in non-highlighted view. */
        cssClass?: String;
        /** Default CSS properties of the HTML text element.The CSS properties which are set here, are handed over to the style property of the HTML text element. That
       /* means, they have higher property than any CSS class.If a property which is set here should be overruled by a CSS class then this property should be removed
       /* here.The reason, why this attribute should be kept to its default value at all, is that screen dumps of SVG boards with board.renderer.dumpToCanvas() will
       /* ignore the font-family if it is set in a CSS class. It has to be set explicitly as style attribute.In summary, the order of priorities from high to low
       /* isJXG.Options.text.cssStyleJXG.Options.text.cssDefaultStyleJXG.Options.text.cssClass */
        cssDefaultStyle?: String;
        /** CSS properties of the HTML text element.The CSS properties which are set here, are handed over to the style property of the HTML text element. That means, they
       /* have higher property than any CSS class. */
        cssStyle?: String;
        /** Used to round texts given by a number. */
        digits?: Number;
        /** Determines the rendering method of the text. Possible values include 'html' and 'internal. */
        display?: String;
        /** Sensitive area for dragging the text. Possible values are 'all', or something else. If set to 'small', a sensitivity margin at the right and left border is
       /* taken. This may be extended to left, right, ... in the future. */
        dragArea?: String;
        /** The font size in pixels. */
        fontSize?: Number;
        /** CSS unit for the font size of a text element. Usually, this will be the default value 'px' but for responsive application, also 'vw', 'vh', vmax', 'vmin' or
       /* 'rem' might be useful. */
        fontUnit?: String;
        /** CSS class of the text in highlighted view. */
        highlightCssClass?: String;
        /** Default CSS properties of the HTML text element in case of highlighting.The CSS properties which are set here, are handed over to the style property of the HTML
       /* text element. That means, they have higher property than any CSS class. */
        highlightCssDefaultStyle?: String;
        /** CSS properties of the HTML text element in case of highlighting.The CSS properties which are set here, are handed over to the style property of the HTML text
       /* element. That means, they have higher property than any CSS class. */
        highlightCssStyle?: String;
        /** Internationalization support for texts consisting of a number only.Setting the local overwrites the board-wide locale set in the board attributes. The JSXGraph
       /* attribute digits is overruled by the Intl attributes "minimumFractionDigits" and "maximumFractionDigits". See
       /* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat for more information about possible options.See
       /* below for an example where the text is composed from a string and a locale formatted number. */
        intl?: object;
        /** If enabled, the text will be handled as label. Intended for internal use. */
        isLabel?: Boolean;
        /** Object or function returning an object that contains macros for KaTeX. */
        katexMacros?: Object;
        /** If set to true, the text is parsed and evaluated. For labels parse==true results in converting names of the form k_a to subscripts. If the text is given by
       /* string and parse==true, the string is parsed as JessieCode expression. */
        parse?: Boolean;
        /** Text rotation in degrees. Works for non-zero values only in combination with display=='internal'. */
        rotate?: Number;
        /** Defines together with Text#snapSizeY the grid the text snaps on to. The text will only snap on integer multiples to snapSizeX in x and snapSizeY in y direction.
       /* If this value is equal to or less than 0, it will use the grid displayed by the major ticks of the default ticks of the default x axes of the board. */
        snapSizeX?: Number;
        /** Defines together with Text#snapSizeX the grid the text snaps on to. The text will only snap on integer multiples to snapSizeX in x and snapSizeY in y direction.
       /* If this value is equal to or less than 0, it will use the grid displayed by the major ticks of the default ticks of the default y axes of the board. */
        snapSizeY?: Number;
        /** If true, the input will be given to ASCIIMathML before rendering. */
        useASCIIMathML?: Boolean;
        /** If set to true and caja's sanitizeHTML function can be found it will be used to sanitize text output. */
        useCaja?: Boolean;
        /** If true, KaTeX will be used to render the input string. For this feature, katex.min.js and katex.min.css have to be included.The example below does not work,
       /* because there is a conflict with the MathJax library which is used below. */
        useKatex?: Boolean;
        /** If true, MathJax will be used to render the input string. Supports MathJax 2 as well as Mathjax 3. It is recommended to use this option together with the option
       /* "parse: false". Otherwise, 4 backslashes (e.g. \\\\alpha) are needed instead of two (e.g. \\alpha). */
        useMathJax?: Boolean;
    }
    /** A circular sector is a subarea of the area enclosed by a circle. It is enclosed by two radii and an arc. */
    interface SectorAttributes extends CurveAttributes {
        /** Attributes for helper point anglepoint in case it is provided by coordinates. */
        anglePoint?: Point;
        /** Attributes for sub-element arc. It is only available, if the sector is defined by three points. */
        arc?: Arc;
        /** Attributes for helper point center in case it is provided by coordinates. */
        center?: Point;
        /** Attributes for the sector label. */
        label?: Label;
        /** Attributes for helper point radiuspoint in case it is provided by coordinates. */
        radiusPoint?: Point;
        /** Type of sector. Possible values are 'minor', 'major', and 'auto'. */
        selection?: String;
    }
    /** The angle element is used to denote an angle defined by three points. Visually it is just a Sector element with a radius not defined by the parent elements but by an attribute radius. As opposed to the sector, an angle has two angle points and no radius point. Sector is displayed if type=="sector". If type=="square", instead of a sector a parallelogram is displayed. In case of type=="auto", a square is displayed if the angle is near orthogonal. If no name is provided the angle label is automatically set to a lower greek letter. */
    interface AngleAttributes extends SectorAttributes {
        /** Attributes for sub-element arc. In general, the arc will run through the first point and thus will not have the same radius as the angle sector. */
        arc?: Arc;
        /** Attributes of the dot point marking right angles. */
        dot?: Object;
        /** Sensitivity (in degrees) to declare an angle as right angle. If the angle measure is inside this distance from a rigth angle, the orthoType of the angle is used
       /* for display. */
        orthoSensitivity?: Number;
        /** Display type of the angle field in case of a right angle. Possible values are 'sector' or 'sectordot' or 'square' or 'none'. */
        orthoType?: String;
        /**  */
        pointsquare?: Object;
        /** Radius of the sector, displaying the angle. The radius can be given as number (in user coordinates) or as string 'auto'. In the latter case, the angle is set to
       /* an value between 20 and 50 px. */
        radius?: Object;
        /**  */
        radiuspoint?: Object;
        /** Display type of the angle field. Possible values are 'sector' or 'sectordot' or 'square' or 'none'. */
        type?: String;
    }
    /** An arc is a segment of the circumference of a circle. It is defined by a center, one point that defines the radius, and a third point that defines the angle of the arc. */
    interface ArcAttributes extends CurveAttributes {
        /** Attributes for angle point. */
        anglePoint?: Point;
        /** Attributes for center point. */
        center?: Point;
        /** If true, moving the mouse over inner points triggers hasPoint. */
        hasInnerPoints?: Boolean;
        /** Attributes for radius point. */
        radiusPoint?: Point;
        /** Type of arc. Possible values are 'minor', 'major', and 'auto'. */
        selection?: String;
    }
    /** This element is used to provide a constructor for arrow, which is just a wrapper for element Line with Line#straightFirst and Line#straightLast properties set to false and Line#lastArrow set to true. */
    interface ArrowAttributes extends LineAttributes {
    }
    /** A parallel is a line through a given point with the same slope as a given line or the line through two given point.If original line is given as a JSXGraph line object, the resulting parallel line will be defined by the given point and an infinitely far away point (an ideal point). That means, the line can not be shortened to a segment.If the original line is given as two points, the resulting parallel line can be shortened to a a segment. */
    interface ParallelAttributes extends LineAttributes {
        /** Attributes of helper point of normal. */
        point?: Point;
    }
    /** An arrow parallel is a segment with an arrow attached which is parallel through a given segment, given by its defining two points, through a given point. */
    interface ArrowparallelAttributes extends ParallelAttributes {
    }
    /** This element is used to provide a constructor for an axis. It's strictly spoken just a wrapper for element Line with Line#straightFirst and Line#straightLast properties set to true. Additionally Line#lastArrow is set to true and default Ticks will be created. */
    interface AxisAttributes extends LineAttributes {
        /** Attributes for the axis label. */
        label?: Label;
        /** Attributes for first point the axis. */
        point1?: Point;
        /** Attributes for second point the axis. */
        point2?: Point;
        /** Attributes for ticks of the axis. */
        ticks?: Ticks;
        /** Show / hide ticks.Deprecated. Suggested alternative is "ticks: {visible: false}" */
        withTicks?: Boolean;
    }
    /** A bisector is a line which divides an angle into two equal angles. It is given by three points A, B, and C and divides the angle ABC into two equal sized parts. */
    interface BisectorAttributes extends LineAttributes {
        /** Attributes for the helper point of the bisector. */
        point?: Point;
    }
    /** Bisector lines are similar to Bisector but take two lines as parent elements. The resulting element is a composition of two lines. */
    interface BisectorlinesAttributes extends CompositionAttributes {
        /** Attributes for first line. */
        line1?: Line;
        /** Attributes for second line. */
        line2?: Line;
    }
    /** Box plot curve. The direction of the box plot can be either vertical or horizontal which is controlled by the attribute "dir". */
    interface BoxplotAttributes extends CurveAttributes {
        /** Direction of the box plot: 'vertical' or 'horizontal' */
        dir?: String;
        /** Relative width of the maximum and minimum quantile */
        smallWidth?: Number;
    }
    /** This element is used to provide a constructor for special texts containing a form button element.For this element, the attribute "display" has to have the value 'html' (which is the default).The underlying HTML button element can be accessed through the sub-object 'rendNodeButton', e.g. to add event listeners. */
    interface ButtonAttributes extends TextAttributes {
        /** Control the attribute "disabled" of the HTML button. */
        disabled?: Boolean;
    }
    interface InitBoardAttributes {
        /** Time (in msec) between two animation steps. */
        animationDelay?: Number;
        /** Show default axis. */
        axis?: Boolean;
        /** Bounding box of the visible area in user coordinates. [left,top,right,bottom] */
        boundingbox?: [Number, Number, Number, Number];
        /** Enable browser scrolling on touch interfaces if the user double taps into an empty region of the board. */
        browserPan?: Boolean;
        /** Attributes for the default axes in case of the attribute axis:true in JXG.JSXGraph#initBoard. */
        defaultAxes?: Object;
        /** Description string for the board. */
        description?: String;
        /** Supply the document object. */
        document?: String;
        /** Control the possibilities for dragging objects. */
        drag?: Object;
        /** Attribute(s) to control the fullscreen icon. */
        fullscreen?: Object;
        /** If set true and hasPoint() is true for both an element and it's label, the element (and not the label) is taken as drag element. */
        ignoreLabels?: Boolean;
        /** Support for internationalization of number formatting. */
        intl?: Object;
        /** If set to true, the ratio between horizontal and vertical unit sizes stays constant - independent of size changes of the hosting HTML div element. */
        keepAspectRatio?: Number;
        /** Control using the keyboard to change the construction. */
        keyboard?: Object;
        /** If enabled, user activities are logged in array "board.userLog". */
        logging?: Boolean;
        /** Maximal bounding box of the visible area in user coordinates. */
        maxBoundingBox?: [Number, Number, Number, Number];
        /** Maximum frame rate of the board, i.e. */
        maxFrameRate?: Number;
        /** Maximum number of digits in automatic label generation. */
        maxNameLength?: Number;
        /** Change redraw strategy in SVG rendering engine. */
        moveTarget?: Object;
        /** A number that will be added to the absolute position of the board used in mouse coordinate calculations in JXG.Board#getCoordsTopLeftCorner. */
        offsetX?: Number;
        /** A number that will be added to the absolute position of the board used in mouse coordinate calculations in JXG.Board#getCoordsTopLeftCorner. */
        offsetY?: Number;
        /** Control the possibilities for panning interaction (i.e. */
        pan?: Object;
        /** Allow user interaction by registering mouse, pointer, keyboard or touch events. */
        registerEvents?: Boolean;
        /** Listen to fullscreen event. */
        registerFullscreenEvent?: Boolean;
        /** Listen to resize events, i.e. */
        registerResizeEvent?: Boolean;
        /** Control if JSXGraph reacts to resizing of the JSXGraph container element by the user / browser. */
        resize?: Boolean;
        /** Attributes to control the screenshot function. */
        screenshot?: Object;
        /** Control the possibilities for a selection rectangle. */
        selection?: Object;
        /** Show a button which allows to clear all traces of a board. */
        showClearTraces?: Boolean;
        /** Show copyright string in canvas. */
        showCopyright?: Boolean;
        /** Show a button in the navigation bar to start fullscreen mode. */
        showFullscreen?: Boolean;
        /** If true, the infobox is shown on mouse/pen over for all points which have set their attribute showInfobox to 'inherit'. */
        showInfobox?: Boolean;
        /** Display of navigation arrows and zoom buttons in the navigation bar. */
        showNavigation?: Number;
        /** Show a button in the navigation bar to force reload of a construction. */
        showReload?: Boolean;
        /** Show a button in the navigation bar to enable screenshots. */
        showScreenshot?: Boolean;
        /** Display of zoom buttons in the navigation bar. */
        showZoom?: Boolean;
        /** If true the first element of the set JXG.board.objects having hasPoint==true is taken as drag element. */
        takeFirst?: Number;
        /** If true, when read from a file or string - the size of the div can be changed by the construction text. */
        takeSizeFromFile?: Number;
        /** Title string for the board. */
        title?: String;
        /** Control the possibilities for zoom interaction. */
        zoom?: Object;
        /** Zoom factor in horizontal direction. */
        zoomX?: Number;
        /** Zoom factor in vertical direction. */
        zoomY?: Number;
    }
    /** Initialize a new board. */
    export class JSXGraph {
        initBoard(html: string, attributes?: InitBoardAttributes): JSXBoard;
        /** Delete a board and all its contents. */
        freeBoard(board: JSXBoard): void;
    }
    export class GeometryElement {
        elValue: Object;
        constructor(elValue: any);
        /** returns the X coordinate of this element */
        X(): number;
        /** returns the Y coordinate of this element */
        Y(): number;
        /** returns the Z coordinate of this element */
        Z(): number;
        /** returns the value of this element */
        Value(): number;
    }
    export class JSXBoard {
        board: JSXBoard | null;
        constructor();
        /** Legacy method to create elements. */
        create(elType: string, params?: any[], attributes?: Object): GeometryElement;
        private dereference;
        transform(dx: Number | Function | Point, dy: Number | [Number, Number] | Function | Point, ttype: 'translate' | 'scale' | 'reflect' | 'rotate' | 'shear' | 'generic', attributes?: Object): Transform;
        /** Angle defined with three points */
        angle(from: Point, around: Point, to: Point, attributes?: AngleAttributes): Angle;
        /** Angle defined with two lines and two directions */
        angle(line1: Line, line2: Line, direction1: [Number, Number], direction2: [Number, Number], attributes?: AngleAttributes): Angle;
        /** Create an Arc with three points  An arc is a segment of the circumference of a circle. It is defined by a center, one point that
       defines the radius, and a third point that defines the angle of the arc.*/
        arc(p1: Point | [Number, Number], p2: Point | [Number, Number], p3: Point | [Number, Number], attributes?: ArcAttributes): Arc;
        /** Arrow defined by two points (like a Line) */
        arrow(p1: Point, p2: Point, attributes?: ArrowAttributes): Arrow;
        /** Arrow defined by three numbers (like a Line) */
        arrow(a: Number, b: Number, c: Number, attributes?: ArrowAttributes): Arrow;
        /** Create an Arrow parallel to a segment. The constructed arrow contains p3 and has the same slope as the line through p1 and p2.  An arrow parallel is a segment with an arrow attached which is parallel through a given segment, given by its defining two points,
       through a given point.*/
        arrowparallel(p1: Point, p2: Point, p3: Point, attributes?: ArrowparallelAttributes): Arrowparallel;
        /** Create an Axis with two points (like a Line) */
        axis(p1: Point, p2: Point, attributes?: AxisAttributes): Axis;
        /** Create an Axis with three number (like a Line) */
        axis(a: Number, b: Number, c: Number, attributes?: AxisAttributes): Axis;
        /** Bisect an Angle defined with three points  A bisector is a line which divides an angle into two equal angles. It is given by three points A, B, and
       C and divides the angle ABC into two equal sized parts.*/
        bisector(p1: Point, p2: Point, p3: Point, attributes?: BisectorAttributes): Bisector;
        /** Bisect a Line defined with two points  Bisector lines are similar to Bisector but take two lines as parent elements. The resulting element is
       a composition of two lines.*/
        bisectorlines(p1: Point, p2: Point, attributes?: BisectorlinesAttributes): Bisectorlines;
        /** Quantiles(array with at least five elements Number|Function|String) plus axis, plus width  Box plot curve. The direction of the box plot can be either vertical or horizontal which
       is controlled by the attribute "dir".*/
        boxplot(q: any[], axis: Number | Function, width: Number | Function, attributes?: BoxplotAttributes): Boxplot;
        /** create a button  This element is used to provide a constructor for special texts containing a
       form button element.

       For this element, the attribute "display" has to have the value 'html' (which is the default).

       The underlying HTML button element can be accessed through the sub-object 'rendNodeButton', e.g. to
       add event listeners.*/
        button(x: Number | Function, y: Number | Function, label: String | Function, handler: Function, attributes?: ButtonAttributes): Button;
        /** Curve  This element is used to provide a constructor for curve, which is just a wrapper for element Curve.
       A curve is a mapping from R to R^2. t mapsto (x(t),y(t)). The graph is drawn for t in the interval [a,b].

       The following types of curves can be plotted:

         parametric curves: t mapsto (x(t),y(t)), where x() and y() are univariate functions.
         polar curves: curves commonly written with polar equations like spirals and cardioids.
         data plots: plot line segments through a given list of coordinates.*/
        curve(x: Number | Function | Arc, y: Number | Function | Transform, attributes?: CurveAttributes): Curve;
        /**   This element is used to provide a constructor for a general line. A general line is given by two points. By setting additional properties
       a line can be used as an arrow and/or axis.*/
        line(p1: Point | [Number, Number] | Function, p2: Point | [Number, Number] | Function, attributes?: LineAttributes): Line;
        /**   This element is used to provide a constructor for a general point. A free point is created if the given parent elements are all numbers
       and the property fixed is not set or set to false. If one or more parent elements is not a number but a string containing a GEONExT
       constraint or a function the point will be considered as constrained). That means that the user won't be able to change the point's
       position directly.*/
        point(x: Number | Function | Point, y: Number | Function | Transform, attributes?: PointAttributes): Point;
        /**   Construct and handle texts.

       The coordinates can either be abslute (i.e. respective to the coordinate system of the board) or be relative to the coordinates of an element
       given in Text#anchor.

       HTML, MathJaX, KaTeX and GEONExT syntax can be handled.

       There are two ways to display texts:

        using the text element of the renderer (canvas or svg). In most cases this is the suitable approach if speed matters.
       However, advanced rendering like MathJax, KaTeX or HTML/CSS are not possible.
        using HTML &lt;div&gt;. This is the most flexible approach. The drawback is that HTML can only be display "above" the geometry elements.
       If HTML should be displayed in an inbetween layer, conder to use an element of type ForeignObject (available in svg renderer, only).*/
        text(x: Number | Function, y: Number | Function, string: String | Function, attributes?: TextAttributes): Text;
    }
    export class Board {
        elValue: Object;
        constructor(elValue: any);
    }
    export class Infobox extends Board {
        constructor(elValues: Board);
    }
    export class CA {
        elValue: Object;
        constructor(elValue: any);
        /** f = map (x) -> x*sin(x);
       Usages:
       h = D(f, x);
       h = map (x) -> D(f, x); */
        expandDerivatives(): any;
        /** Declare all subnodes as math nodes,
       i.e recursively set node.isMath = true; */
        setMath(): any;
    }
    export class Chart {
        elValue: Object;
        constructor(elValue: any);
        /** Contains pointers to the various subelements of the chart. */
        get elements(): Number[];
        /** Create bar chart defined by two data arrays. */
        drawBar(): Number[];
        /** Create line chart where the curve is given by a regression polynomial
       defined by two data arrays. */
        drawFit(): Curve;
        /** Create line chart defined by two data arrays. */
        drawLine(): Curve;
        /** Create pie chart. */
        drawPie(): Object;
        /** Create chart consisting of JSXGraph points. */
        drawPoints(): Number[];
        /** Create radar chart. */
        drawRadar(): Object;
        /** Create line chart that consists of a natural spline curve
       defined by two data arrays. */
        drawSpline(): Curve;
        /** Template for dynamic charts update. */
        updateDataArray(): Chart;
    }
    export class Circle {
        elValue: Object;
        constructor(elValue: any);
        /** The circles center. */
        get center(): Point;
        /** Circle defining the radius of the circle given by the radius of the other circle
       only set if method equals 'pointLine'. */
        get circle(): Circle;
        /** Line defining the radius of the circle given by the distance from the startpoint and the endpoint of the line
       only set if method equals 'pointLine'. */
        get line(): Line;
        /** Stores the given method. */
        get method(): String;
        /** Point on the circle only set if method equals 'twoPoints'. */
        get point2(): Point;
        /** Radius of the circle
       only set if method equals 'pointRadius' */
        get radius(): Number;
        /** Add transformations to this circle. */
        addTransform(): Circle;
        /** Circle area */
        Area(): Number;
        /** Get bounding box of the circle. */
        bounds(): Number[];
        /** Get data to construct this element. */
        getParents(): Number[];
        /** Use <a href="../symbols/JXG.Circle.html#Radius">JXG.Circle#Radius</a>. */
        getRadius(): Boolean;
        /** Perimeter (circumference) of circle. */
        Perimeter(): Number;
        /** Calculates the radius of the circle. */
        Radius(): Number;
        /** Set a new radius, then update the board. */
        setRadius(): Circle;
        /** Uses the boards renderer to update the circle. */
        update(): Number;
    }
    export class Complex {
        elValue: Object;
        constructor(elValue: any);
        /** Absolute value in the polar form of the complex number. */
        get absval(): Number;
        /** Angle value in the polar form of the complex number. */
        get angle(): Number;
        /** Imaginary part of the complex number. */
        get imaginary(): Number;
        /** This property is only to signalize that this object is of type JXG.Complex. */
        get isComplex(): Boolean;
        /** Real part of the complex number. */
        get real(): Number;
        /** Add another complex number to this complex number. */
        add(): Complex;
        /** Conjugate a complex number in place. */
        conj(): Complex;
        /** Divide this complex number by the given complex number. */
        div(): Complex;
        /** Multiply another complex number to this complex number. */
        mult(): Complex;
        /** Subtract another complex number from this complex number. */
        sub(): Complex;
        /** Converts a complex number into a string. */
        toString(): String;
    }
    export class Composition {
        elValue: Object;
        constructor(elValue: any);
        /** Adds an element to the composition container. */
        add(): Boolean;
        /** Invokes fullUpdate for every stored element with a fullUpdate method and hands over the given arguments. */
        fullUpdate(): Boolean;
        /** Invokes highlight for every stored element with a highlight method and hands over the given arguments. */
        highlight(): Boolean;
        /** Invokes noHighlight for every stored element with a noHighlight method and hands over the given arguments. */
        noHighlight(): Boolean;
        /** Invokes prepareUpdate for every stored element with a prepareUpdate method and hands over the given arguments. */
        prepareUpdate(): Boolean;
        /** Remove an element from the composition container. */
        remove(): Boolean;
        /** Invokes setAttribute for every stored element with a setAttribute method and hands over the given arguments. */
        setAttribute(): any;
        /** Invokes setParents for every stored element with a setParents method and hands over the given arguments. */
        setParents(): any;
        /** Invokes update for every stored element with a update method and hands over the given arguments. */
        update(): any;
        /** Invokes updateRenderer for every stored element with a updateRenderer method and hands over the given arguments. */
        updateRenderer(): any;
    }
    export class Coords {
        elValue: Object;
        constructor(elValue: any);
        /** Stores the board the object is used on. */
        get board(): Board;
        /** If true, this coordinates object will emit update events every time
       the coordinates are set. */
        get emitter(): boolean;
        /** Stores coordinates for screen view as homogeneous coordinates. */
        get scrCoords(): Number[];
        /** Stores coordinates for user view as homogeneous coordinates. */
        get usrCoords(): Number[];
        /** Calculate distance of one point to another. */
        distance(): Number;
        /** Test if one of the usrCoords is NaN or the coordinates are infinite. */
        isReal(): Boolean;
        /** Set coordinates by either user coordinates or screen coordinates and recalculate the other one. */
        setCoordinates(): Coords;
    }
    export class CoordsElement extends GeometryElement {
        constructor(elValues: GeometryElement);
        /** Coordinates of the element. */
        get coords(): Coords;
        /** Stores the groups of this element in an array of Group. */
        get groups(): Number[];
        /** True if there the method this.updateConstraint() has been set. */
        get isConstrained(): Boolean;
        /** A <a href="../symbols/JXG.CoordsElement.html#updateGlider">JXG.CoordsElement#updateGlider</a> call is usually followed
       by a general <a href="../symbols/JXG.Board.html#update">JXG.Board#update</a> which calls
       <a href="../symbols/JXG.CoordsElement.html#updateGliderFromParent">JXG.CoordsElement#updateGliderFromParent</a>. */
        get needsUpdateFromParent(): Boolean;
        /** Determines whether the element slides on a polygon if point is a glider. */
        get onPolygon(): Boolean;
        /** Relative position on a slide element (line, circle, curve) if element is a glider on this element. */
        get position(): Number;
        /** When used as a glider this member stores the object, where to glide on. */
        get slideObject(): GeometryElement;
        /** List of elements the element is bound to, i.e. */
        get slideObjects(): CoordsElement;
        /** Convert the point to CAS point and call update(). */
        addConstraint(): CoordsElement;
        /** Add transformations to this element. */
        addTransform(): CoordsElement;
        /** Generic method to create point, text or image. */
        create(): Coords;
        /** Getter method for the distance to a second point, this is required for CAS-elements. */
        Dist(): Number;
        /** Converts a calculated element into a free element,
       i.e. */
        free(): Point;
        /** A point can change its type from free point to glider
       and vice versa. */
        handleAttractors(): Point;
        /** Let a point snap to the nearest point in distance of
       JXG.Point#attractorDistance. */
        handleSnapToPoints(): Point;
        /** Convert the point to glider and update the construction. */
        makeGlider(): CoordsElement;
        /** Starts an animation which moves the point along a given path in given time. */
        moveAlong(): CoordsElement;
        /** Starts an animated point movement towards the given coordinates <tt>where</tt>. */
        moveTo(): CoordsElement;
        /** Remove the last slideObject. */
        popSlideObject(): Point;
        /** Sets the position of a glider relative to the defining elements
       of the JXG.Point#slideObject. */
        setGliderPosition(): Point;
        /** Sets coordinates and calls the point's update() method. */
        setPosition(): Point;
        /** Translates the point by <tt>tv = (x, y)</tt>. */
        setPositionByTransform(): Point;
        /** Sets coordinates and calls the point's update() method. */
        setPositionDirectly(): Point;
        /** Alias for JXG.Element#handleSnapToGrid */
        snapToGrid(): CoordsElement;
        /** Alias for <a href="../symbols/JXG.CoordsElement.html#handleSnapToPoints">JXG.CoordsElement#handleSnapToPoints</a>. */
        snapToPoints(): Point;
        /** Applies the transformations of the element. */
        updateTransform(): CoordsElement;
        /** Starts an animated point movement towards the given coordinates <tt>where</tt>. */
        visit(): CoordsElement;
    }
    export class Curve extends GeometryElement {
        constructor(elValues: GeometryElement);
        /** Array holding the x-coordinates of a data plot. */
        get dataX(): Number[];
        /** Array holding the y-coordinates of a data plot. */
        get dataY(): Number[];
        /** Array of ticks storing all the ticks on this curve. */
        get ticks(): Number[];
        /** Add transformations to this curve. */
        addTransform(): Curve;
        /** Allocate points in the Coords array this.points */
        allocatePoints(): Number[];
        /** Converts the JavaScript/JessieCode/GEONExT syntax of the defining function term into JavaScript. */
        generateTerm(): Number[];
        /** Checks whether (x,y) is near the curve. */
        hasPoint(): Boolean;
        /** Gives the default value of the right bound for the curve. */
        maxX(): Number;
        /** Gives the default value of the left bound for the curve. */
        minX(): Number;
        /** Shift the curve by the vector 'where'. */
        moveTo(): Curve;
        /** Finds dependencies in a given term and notifies the parents by adding the
       dependent object to the found objects child elements. */
        notifyParents(): Curve;
        /** Computes for equidistant points on the x-axis the values of the function */
        update(): Curve;
        /** Computes the curve path */
        updateCurve(): Curve;
        /** For dynamic dataplots updateCurve can be used to compute new entries
       for the arrays <a href="../symbols/JXG.Curve.html#dataX">JXG.Curve#dataX</a> and <a href="../symbols/JXG.Curve.html#dataY">JXG.Curve#dataY</a>. */
        updateDataArray(): Curve;
        /** Updates the visual contents of the curve. */
        updateRenderer(): Curve;
        /** Applies the transformations of the curve to the given point <tt>p</tt>. */
        updateTransform(): Point;
    }
    export class Curve3D extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class Dump {
        elValue: Object;
        constructor(elValue: any);
    }
    export class ForeignObject {
        elValue: Object;
        constructor(elValue: any);
        /** 'href' of the foreignObject. */
        get content(): Number[];
        /** Array of length two containing [width, height] of the foreignObject in pixel. */
        get size(): Number[];
        /** Returns the height of the foreignObject in user coordinates. */
        H(): number;
        /** Checks whether (x,y) is over or near the image; */
        hasPoint(): Boolean;
        /** Set the width and height of the foreignObject. */
        setSize(): ForeignObject;
        /** Returns the width of the foreignObject in user coordinates. */
        W(): number;
    }
    export class GeometryElement3D {
        elValue: Object;
        constructor(elValue: any);
    }
    export class Group {
        elValue: Object;
        constructor(elValue: any);
        /** Cache coordinates of points. */
        get coords(): Object;
        /** Adds all points in a group to this group. */
        addGroup(): Group;
        /** Adds ids of elements to the array this.parents. */
        addParents(): Object;
        /** Adds an Point to this group. */
        addPoint(): Group;
        /** Adds multiple points to this group. */
        addPoints(): Group;
        /** Adds a point to the set of rotation points of the group. */
        addRotationPoint(): Group;
        /** Adds a point to the set of the scale points of the group. */
        addScalePoint(): Group;
        /** Adds a point to the set of the translation points of the group. */
        addTranslationPoint(): Group;
        /** List of the element ids resp. */
        getParents(): Number[];
        /** Removes a point from the group. */
        removePoint(): Group;
        /** Removes the rotation property from a point of the group. */
        removeRotationPoint(): Group;
        /** Removes the scaling property from a point of the group. */
        removeScalePoint(): Group;
        /** Removes the translation property from a point of the group. */
        removeTranslationPoint(): Group;
        /** Sets ids of elements to the array this.parents. */
        setParents(): Object;
        /**  */
        setProperty(): Group;
        /** Sets the center of rotation for the group. */
        setRotationCenter(): Group;
        /** Sets the rotation points of the group. */
        setRotationPoints(): Group;
        /** Sets the center of scaling for the group. */
        setScaleCenter(): Group;
        /** Sets the scale points of the group. */
        setScalePoints(): Group;
        /** Sets the translation points of the group. */
        setTranslationPoints(): Group;
        /** Releases all elements of this group. */
        ungroup(): Group;
        /** Sends an update to all group members. */
        update(): Group;
    }
    export class Image {
        elValue: Object;
        constructor(elValue: any);
        /** Array of length two containing [width, height] of the image in pixel. */
        get size(): Number[];
        /** 'href' of the image. */
        get url(): string;
        /** Returns the height of the image in user coordinates. */
        H(): number;
        /** Checks whether (x,y) is over or near the image; */
        hasPoint(): Boolean;
        /** Set the width and height of the image. */
        setSize(): GeometryElement;
        /** Returns the width of the image in user coordinates. */
        W(): number;
    }
    export class Legend {
        elValue: Object;
        constructor(elValue: any);
        /** (Circular) array of label colors. */
        get colors(): Number[];
        /** Label names of a legend element. */
        get labels(): Number[];
        /** Height (in px) of one legend entry */
        get rowHeight(): Number;
        /** Default style of a legend element. */
        get style(): String;
    }
    export class Line extends GeometryElement {
        constructor(elValues: GeometryElement);
        /** Reference of the ticks created automatically when constructing an axis. */
        get defaultTicks(): Ticks;
        /** If the line is the border of a polygon, the polygon object is stored, otherwise null. */
        get parentPolygon(): Polygon;
        /** Startpoint of the line. */
        get point1(): Point;
        /** Endpoint of the line. */
        get point2(): Point;
        /** Array of ticks storing all the ticks on this line. */
        get ticks(): Number[];
        /** Add transformations to this line. */
        addTransform(): Line;
        /** Determines the angle between the positive x axis and the line. */
        getAngle(): Number;
        /** Calculates the y intersect of the line. */
        getRise(): Number;
        /** Alias for line.Slope */
        getSlope(): Number;
        /** Checks whether (x,y) is near the line. */
        hasPoint(): Boolean;
        /** The distance between the two points defining the line. */
        L(): Number;
        /** Calculates the slope of the line. */
        Slope(): Number;
    }
    export class Line3D extends GeometryElement3D {
        constructor(elValues: GeometryElement3D);
        /** Direction which - together with a point - defines the line. */
        get direction(): Number[] | Function;
        /** 3D point which - together with a direction - defines the line. */
        get point(): Point3D;
        /** Starting point of the 3D line */
        get point1(): Point3D;
        /** End point of the 3D line */
        get point2(): Point3D;
        /** Range [r1, r2] of the line. */
        get range(): Number[];
    }
    export class Plane3D extends GeometryElement {
        constructor(elValues: GeometryElement);
        /** Right hand side of the Hesse normal form. */
        get d(): Number[];
        /** Two linearly independent vectors - together with a point - define the plane. */
        get direction1(): Number[] | Function;
        /** Two linearly independent vectors - together with a point - define the plane. */
        get direction2(): Number[] | Function;
        /** Normal vector of the plane. */
        get normal(): Number[];
        /** 3D point which - together with two direction vectors - defines the plane. */
        get point(): Point3D;
        /** Range [r1, r2] of direction1. */
        get range1(): Number[];
        /** Range [r1, r2] of direction2. */
        get range2(): Number[];
        /** Direction vector 1 of the 3D plane. */
        get vec1(): Number[];
        /** Direction vector 2 of the 3D plane. */
        get vec2(): Number[];
    }
    export class Point extends GeometryElement {
        constructor(elValues: GeometryElement);
        /** Test if the point is on (is incident with) element "el". */
        isOn(): Boolean;
        /** Convert the point to intersection point and update the construction. */
        makeIntersection(): Point;
        /** Updates the position of the point. */
        update(): CoordsElement;
        /** Applies the transformations of the element to JXG.Point#baseElement. */
        updateTransform(): CoordsElement;
    }
    export class Point3D {
        elValue: Object;
        constructor(elValue: any);
        /** Homogeneous coordinates of a Point3D, i.e. */
        get coords(): Number[];
        /** Optional slide element, i.e. */
        get slide(): GeometryElement3D;
        /** Set the position of a 3D point. */
        setPosition(): Number[];
        /** Get x-coordinate of a 3D point. */
        X(): Number[];
        /** Get y-coordinate of a 3D point. */
        Y(): Number[];
        /** Get z-coordinate of a 3D point. */
        Z(): Number[];
    }
    export class Polygon {
        elValue: Object;
        constructor(elValue: any);
        /** References to the border lines of the polygon. */
        get borders(): Number[];
        /** References to the points defining the polygon. */
        get vertices(): Number[];
        /** Add more points to the polygon. */
        addPoints(): Polygon;
        /** Area of (not self-intersecting) polygon */
        Area(): Number;
        /** Bounding box of a polygon. */
        boundingBox(): Number[];
        /** Finds the index to a given point reference. */
        findPoint(): Number;
        /** return TextAnchor */
        getTextAnchor(): Boolean;
        /** Checks whether (x,y) is near the polygon. */
        hasPoint(): Boolean;
        /** Hide the polygon including its border lines. */
        hideElement(): Polygon;
        /** Insert points to the vertex list of the polygon after index <tt>idx</tt>. */
        insertPoints(): Polygon;
        /** Generic method for the intersection of this polygon with another polygon. */
        intersect(): Number[];
        /** Alias for Perimeter. */
        L(): Number;
        /** Perimeter of polygon. */
        Perimeter(): Number;
        /** Wrapper for JXG.Math.Geometry.pnpoly. */
        pnpoly(): Boolean;
        /** Removes given set of vertices from the polygon */
        removePoints(): Polygon;
        /** Moves the polygon by the difference of two coordinates. */
        setPositionDirectly(): Polygon;
        /** Make the element visible. */
        showElement(): Number[];
        /** Uses the boards renderer to update the polygon. */
        updateRenderer(): any;
    }
    export class Surface3D extends GeometryElement {
        constructor(elValues: GeometryElement);
        /** Function which maps (u, v) to x; i.e. */
        X(): any;
        /** Function which maps (u, v) to y; i.e. */
        Y(): any;
        /** Function which maps (u, v) to z; i.e. */
        Z(): any;
    }
    export class Text extends GeometryElement {
        constructor(elValues: GeometryElement);
        /** Width and height of the text element in pixel. */
        get size(): Number[];
        /** Returns the bounding box of the text element in user coordinates as an
       array of length 4: [upper left x, upper left y, lower right x, lower right y]. */
        bounds(): Number[];
        /** A very crude estimation of the dimensions of the textbox in case nothing else is available. */
        crudeSizeEstimate(): Number[];
        /** Returns the value of the attribute "anchorX". */
        getAnchorX(): Number;
        /** Returns the value of the attribute "anchorY". */
        getAnchorY(): Number;
        /** Return the width of the text element. */
        getSize(): Number[];
        /** Replace _{} by &lt;sub&gt; */
        replaceSub(): String;
        /** Replace ^{} by &lt;sup&gt; */
        replaceSup(): String;
        /** Sets the offset of a label element to the position with the least number
       of overlaps with other elements, while retaining the distance to its
       anchor element. */
        setAutoPosition(): Text;
        /** Move the text to new coordinates. */
        setCoords(x: Number, y: Number): object;
        /** Defines new content. */
        setText(newText: String): Text;
        /** Defines new content but converts &lt; and &gt; to HTML entities before updating the DOM. */
        setTextJessieCode(): this;
        /** Evaluates the text. */
        update(): this;
        /** Recompute the width and the height of the text box. */
        updateSize(): this;
        /** Decode unicode entities into characters. */
        utf8_decode(): String;
    }
    export class Ticks extends GeometryElement {
        constructor(elValues: GeometryElement);
        /** The board the ticks line is drawn on. */
        get board(): Board;
        /** Flag if the ticks are equidistant. */
        get equidistant(): Boolean;
        /** Array of fixed ticks. */
        get fixedTicks(): Number[];
        /** Used to ensure the uniqueness of label ids this counter is used. */
        get labelCounter(): number;
        /** Array where the labels are saved. */
        get labels(): Number[];
        /** A list of labels which have to be displayed in updateRenderer. */
        get labelsData(): Number[];
        /** The line the ticks belong to. */
        get line(): Line;
        /** Stores the ticks coordinates */
        get ticks(): Number[];
        /** Formats label texts to make labels displayed in scientific notation look beautiful. */
        beautifyScientificNotationLabel(): String;
        /** Checks whether (x,y) is near the line. */
        hasPoint(): Boolean;
        /** Sets x and y coordinate of the tick. */
        setPositionDirectly(): Ticks;
        /** Recalculate the tick positions and the labels. */
        update(): Ticks;
        /** Uses the boards renderer to update the arc. */
        updateRenderer(): Ticks;
    }
    export class Transform {
        elValue: Object;
        constructor(elValue: any);
    }
    export class Turtle extends GeometryElement {
        constructor(elValues: GeometryElement);
        /** Move the turtle backwards. */
        back(): Turtle;
        /** Alias for <a href="../symbols/JXG.Turtle.html#back">JXG.Turtle#back</a> */
        bk(): Turtle;
        /** Removes the turtle curve from the board. */
        clean(): Turtle;
        /** Removes the turtle completely and resets it to its initial position and direction. */
        clearScreen(): Turtle;
        /** Alias for <a href="../symbols/JXG.Turtle.html#clearScreen">JXG.Turtle#clearScreen</a> */
        cs(): Number;
        /** The "co"-coordinate of the turtle curve at position t is returned. */
        evalAt(): Number;
        /** Alias for <a href="../symbols/JXG.Turtle.html#forward">JXG.Turtle#forward</a> */
        fd(): Turtle;
        /** Move the turtle forward. */
        forward(): Turtle;
        /** Get most recently set turtle color. */
        getHighlightPenColor(): Boolean;
        /** Get most recently set turtle color. */
        getPenColor(): Boolean;
        /** Get most recently set turtle size (in pixel). */
        getPenSize(): Boolean;
        /** Checks whether (x,y) is near the curve. */
        hasPoint(): Boolean;
        /** Sets the visibility of the turtle head to false, */
        hideTurtle(): Turtle;
        /** Moves the turtle to position [0,0]. */
        home(): Turtle;
        /** Alias for <a href="../symbols/JXG.Turtle.html#hideTurtle">JXG.Turtle#hideTurtle</a> */
        ht(): Turtle;
        /** Rotate the turtle direction to the right. */
        left(): Turtle;
        /** Rotates the turtle into a new direction. */
        lookTo(): Turtle;
        /** Alias for <a href="../symbols/JXG.Turtle.html#left">JXG.Turtle#left</a> */
        lt(): Turtle;
        /** Gives the upper bound of the parameter if the turtle is treated as parametric curve. */
        maxX(): Turtle;
        /** Gives the lower bound of the parameter if the turtle is treated as parametric curve. */
        minX(): Turtle;
        /** Moves the turtle to a given coordinate pair. */
        moveTo(): Turtle;
        /** Alias for <a href="../symbols/JXG.Turtle.html#penDown">JXG.Turtle#penDown</a> */
        pd(): Turtle;
        /** Pen down, continues visible drawing */
        penDown(): Turtle;
        /** Pen up, stops visible drawing */
        penUp(): Turtle;
        /** Alias for <a href="../symbols/JXG.Turtle.html#popTurtle">JXG.Turtle#popTurtle</a> */
        pop(): Turtle;
        /** Gets the last position of the turtle on the stack, sets the turtle to this position and removes this
       position from the stack. */
        popTurtle(): Turtle;
        /** Alias for <a href="../symbols/JXG.Turtle.html#penUp">JXG.Turtle#penUp</a> */
        pu(): Turtle;
        /** Alias for <a href="../symbols/JXG.Turtle.html#pushTurtle">JXG.Turtle#pushTurtle</a> */
        push(): Turtle;
        /** Pushes the position of the turtle on the stack. */
        pushTurtle(): Turtle;
        /** Rotate the turtle direction to the right */
        right(): Turtle;
        /** Alias for <a href="../symbols/JXG.Turtle.html#right">JXG.Turtle#right</a> */
        rt(): Turtle;
        /** Sets properties of the turtle, see also <a href="../symbols/JXG.GeometryElement.html#setAttribute">JXG.GeometryElement#setAttribute</a>. */
        setAttribute(): Turtle;
        /** Sets the highlight pen color. */
        setHighlightPenColor(): Turtle;
        /** Sets the pen color. */
        setPenColor(): Turtle;
        /** Sets the pen size. */
        setPenSize(): Turtle;
        /** Moves the turtle without drawing to a new position */
        setPos(): Turtle;
        /** Sets the visibility of the turtle head to true, */
        showTurtle(): Turtle;
        /** Alias for <a href="../symbols/JXG.Turtle.html#showTurtle">JXG.Turtle#showTurtle</a> */
        st(): Number;
    }
    export class View3D extends GeometryElement {
        constructor(elValues: GeometryElement);
        /** Slider to adapt azimuth angle */
        get az_slide(): Number[];
        /** Bounding box (cube) [[x1, x2], [y1,y2], [z1,z2]] of the 3D view */
        get bbox3D(): Number[];
        /** Default axes of the 3D view, contains the axes of the view or null. */
        get defaultAxes(): Object;
        /** Slider to adapt elevation angle */
        get el_slide(): Object;
        /** An associative array / dictionary to store the objects of the board by name. */
        get elementsByName(): Object;
        /**  */
        get llftCorner(): Number[];
        /**  */
        get matrix3D(): Object;
        /** An associative array containing all geometric objects belonging to the view. */
        get objects(): Object;
        /** Distance of the view to the origin. */
        get r(): Number;
        /** Width and height [w, h] of the 3D view if elevation and azimuth are set to 0. */
        get size(): Number[];
        /**  */
        animateAzimuth(): Object;
        /** Creates a new 3D element of type elementType. */
        create(): Object;
        /** Intersect a ray with the bounding cube of the 3D view. */
        intersectionLineCube(): Number[];
        /**  */
        intersectionPlanePlane(): Number[];
        /** Test if coordinates are inside of the bounding cube. */
        isInCube(): Number[];
        /** Project a 2D coordinate to the plane defined by the point foot
       and the normal vector `normal`. */
        project2DTo3DPlane(): Number[];
        /** Project a 2D coordinate to a new 3D position by keeping
       the 3D x, y coordinates and changing only the z coordinate. */
        project2DTo3DVertical(): Number[];
        /** Project 3D coordinates to 2D board coordinates
       The 3D coordinates are provides as three numbers x, y, z or one array of length 3. */
        project3DTo2D(): Number[];
        /** Limit 3D coordinates to the bounding cube. */
        project3DToCube(): GeometryElement3D | Composition;
        /** Select a single or multiple elements at once. */
        select(): GeometryElement3D | Composition;
        /**  */
        stopAzimuth(): any;
    }
    export class Sector extends GeometryElement {
        constructor(elValues: GeometryElement);
        /** Midpoint of the sector. */
        get point1(): Point;
        /** This point together with <a href="../symbols/Sector.html#point1">Sector#point1</a> defines the radius. */
        get point2(): Point;
        /** Defines the sector's angle. */
        get point3(): Point;
        /** Defines the sectors orientation in case of circumCircleSectors. */
        get point4(): Point;
        /** Checks whether (x,y) is within the area defined by the sector. */
        hasPointSector(): Boolean;
        /** Returns the radius of the sector. */
        Radius(): Number;
    }
    export class Vectorfield extends GeometryElement {
        constructor(elValues: GeometryElement);
        /** Set the defining functions of vector field. */
        setF(): Object;
    }
    export class Angle extends Sector {
        constructor(elValues: Sector);
        /** The point defining the radius of the angle element. */
        get point(): Point;
        /** Frees an angle from a prescribed value. */
        free(): Object;
        /** Set an angle to a prescribed value given in radians. */
        setAngle(): Object;
    }
    export class Arc extends GeometryElement {
        constructor(elValues: GeometryElement);
        /** The point defining the arc's angle. */
        get anglepoint(): Point;
        /** Point defining the arc's radius. */
        get radiuspoint(): Point;
        /**  */
        getRadius(): Number;
        /** Checks whether (x,y) is within the sector defined by the arc. */
        hasPointSector(): Boolean;
        /** Determines the arc's current radius. */
        Radius(): Number;
    }
    export class Arrow extends Line {
        constructor(elValues: Line);
    }
    export class Parallel extends Line {
        constructor(elValues: Line);
    }
    export class Arrowparallel extends Parallel {
        constructor(elValues: Parallel);
    }
    export class Axis extends Line {
        constructor(elValues: Line);
        /** The ticks attached to the axis. */
        get defaultTicks(): Ticks;
    }
    export class Bisector extends Line {
        constructor(elValues: Line);
    }
    export class Bisectorlines extends Composition {
        constructor(elValues: Composition);
    }
    export class Boxplot extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class Button extends Text {
        constructor(elValues: Text);
    }
    export class Cardinalspline extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class Checkbox extends Text {
        constructor(elValues: Text);
        /** Returns the value of the checkbox element */
        Value(): number;
    }
    export class Circumcenter extends Point {
        constructor(elValues: Point);
    }
    export class Circumcircle extends Circle {
        constructor(elValues: Circle);
    }
    export class CircumcircleArc extends Arc {
        constructor(elValues: Arc);
    }
    export class CircumcircleSector extends Sector {
        constructor(elValues: Sector);
        /** Center of the circumcirclesector */
        get center(): Circumcenter;
    }
    export class Comb extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class Conic extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class CurveDifference extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class CurveIntersection extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class CurveUnion extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class Derivative extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class Ellipse extends Conic {
        constructor(elValues: Conic);
    }
    export class Functiongraph extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class ParametricSurface3D extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class Functiongraph3D extends ParametricSurface3D {
        constructor(elValues: ParametricSurface3D);
    }
    export class Glider extends Point {
        constructor(elValues: Point);
        /** Animate the point. */
        startAnimation(): CoordsElement;
        /** Stop animation. */
        stopAnimation(): CoordsElement;
    }
    export class Grid extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class Hatch extends Ticks {
        constructor(elValues: Ticks);
        /** The default distance (in user coordinates, not  pixels) between two hatch symbols. */
        get ticksDistance(): Number;
    }
    export class Hyperbola extends Conic {
        constructor(elValues: Conic);
    }
    export class Incenter extends Point {
        constructor(elValues: Point);
    }
    export class Incircle extends Circle {
        constructor(elValues: Circle);
    }
    export class Inequality extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class Input extends Text {
        constructor(elValues: Text);
        /** Sets value of the input element. */
        set(): GeometryElement;
        /** Returns the value (content) of the input element */
        Value(): number;
    }
    export class Integral extends GeometryElement {
        constructor(elValues: GeometryElement);
        /** The point on the axis initially corresponding to the lower value of the interval. */
        get baseLeft(): Point;
        /** The point on the axis initially corresponding to the higher value of the interval. */
        get baseRight(): Point;
        /** The glider on the curve corresponding to the lower value of the interval. */
        get curveLeft(): Point;
        /** The glider on the axis corresponding to the higher value of the interval. */
        get curveRight(): Point;
        /** Returns the current value of the integral. */
        Value(): number;
    }
    export class Intersection extends Point {
        constructor(elValues: Point);
    }
    export class Label extends Text {
        constructor(elValues: Text);
    }
    export class Locus extends GeometryElement {
        constructor(elValues: GeometryElement);
        /** The time it took to calculate the locus */
        get ctime(): Number;
        /** The implicit definition of the locus. */
        get eq(): String;
    }
    export class MajorArc extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class MajorSector extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class Metapostspline extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class Midpoint extends Point {
        constructor(elValues: Point);
    }
    export class MinorArc extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class MinorSector extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class mirrorelement extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class Mirrorpoint extends Point {
        constructor(elValues: Point);
    }
    export class NonReflexAngle extends Angle {
        constructor(elValues: Angle);
    }
    export class Normal extends Line {
        constructor(elValues: Line);
    }
    export class Orthogonalprojection extends Point {
        constructor(elValues: Point);
    }
    export class OtherIntersection extends Point {
        constructor(elValues: Point);
    }
    export class Parabola extends Conic {
        constructor(elValues: Conic);
    }
    export class Parallelpoint extends Point {
        constructor(elValues: Point);
    }
    export class Segment extends Line {
        constructor(elValues: Line);
    }
    export class Perpendicular extends Segment {
        constructor(elValues: Segment);
    }
    export class PerpendicularPoint extends Point {
        constructor(elValues: Point);
    }
    export class PerpendicularSegment extends Segment {
        constructor(elValues: Segment);
        /** Helper point */
        get point(): PerpendicularPoint;
    }
    export class PolarLine extends Line {
        constructor(elValues: Line);
    }
    export class PolePoint extends Point {
        constructor(elValues: Point);
    }
    export class PolygonalChain extends Polygon {
        constructor(elValues: Polygon);
    }
    export class RadicalAxis extends Line {
        constructor(elValues: Line);
    }
    export class Reflection extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class ReflexAngle extends Angle {
        constructor(elValues: Angle);
    }
    export class RegularPolygon extends Polygon {
        constructor(elValues: Polygon);
    }
    export class Riemannsum extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class Semicircle extends Arc {
        constructor(elValues: Arc);
        /** The midpoint of the two defining points. */
        get midpoint(): Midpoint;
    }
    export class Slider extends Glider {
        constructor(elValues: Glider);
        /** End value of the slider range. */
        get _smax(): Number;
        /** Start value of the slider range. */
        get _smin(): Number;
        /** Sets the maximum value of the slider. */
        setMax(): Object;
        /** Sets the minimum value of the slider. */
        setMin(): Object;
        /** Sets the value of the slider. */
        setValue(): Object;
    }
    export class Slopefield extends Vectorfield {
        constructor(elValues: Vectorfield);
        /** Set the defining functions of slope field. */
        setF(): Object;
    }
    export class Slopetriangle extends Line {
        constructor(elValues: Line);
    }
    export class Smartlabel extends Text {
        constructor(elValues: Text);
    }
    export class Spline extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class Stepfunction extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export class Tangent extends Line {
        constructor(elValues: Line);
    }
    export class Tapemeasure extends Segment {
        constructor(elValues: Segment);
    }
    export class Tracecurve extends GeometryElement {
        constructor(elValues: GeometryElement);
    }
    export {};
}
